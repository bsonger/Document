[{"id":0,"href":"/docs/go/first/","title":"First","section":"Go","content":" Golang的基本介绍 # "},{"id":1,"href":"/docs/go/","title":"Go","section":"文档首页","content":"本章节介绍 Hugo 的基本使用。\n"},{"id":2,"href":"/docs/kubernetes/operate/install/","title":"install","section":"operate","content":"欢迎使用kubernetes\n"},{"id":3,"href":"/docs/kubernetes/operate/install/kubernetes/","title":"kubernetes","section":"install","content":" 部署前准备 # 修改机器名 hostnamectl set-hostname master 关闭swap swapoff -a sed -i \u0026#39;/swap / s/^\\(.*\\)$/#\\1/g\u0026#39; /etc/fstab free -m # 检查是否关闭swap ssh允许Root 登陆 vim /etc/ssh/sshd_config 增加 Port 22 PermitRootLogin yes passwd # 设置root 密码 关闭防火墙 sudo ufw disable 修改apt 源地址 cp /etc/apt/sources.list /etc/apt/sources.list.bak # 使用vim 替换/etc/apt/sources.list中的资源地址 vim /etc/apt/sources.list deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse # 更新 vim /etc/resolv.conf # 添加一下两行 nameserver 8.8.8.8 nameserver 8.8.4.4 apt-get update 添加 Kubernetes apt 存储库 sudo tee /etc/apt/sources.list.d/kubernetes.list \u0026lt;\u0026lt;-\u0026#39;EOF\u0026#39; deb https://mirrors.aliyun.com/kubernetes/apt kubernetes-xenial main EOF apt-get update The following signatures couldn\u0026#39;t be verified because the public key is not available: NO_PUBKEY B53DC80D13EDEF05 NO_PUBKEY FEEA9169307EA071 # 如果报错以上错误，执行下面一条命令 recv-keys 是报错现实的NO_PUBKEY sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys FEEA9169307EA071 安装kubectl kubeadm kubelet sudo apt-get install -y kubelet=1.22.2-00 kubeadm=1.22.2-00 kubectl=1.22.2-00 安装docker apt-get install -y docker.io systemctl enable docker master # 安装master 节点 kubeadm init \\ --apiserver-advertise-address=192.168.31.239 \\ --image-repository registry.aliyuncs.com/google_containers \\ --kubernetes-version v1.22.0 \\ --service-cidr=10.96.0.0/12 \\ --pod-network-cidr=10.244.0.0/16 node # 安装node 节点 kubeadm join 192.168.31.208:6443 --token u1soc8.1xyeqbzptpvvjz8f --discovery-token-ca-cert-hash sha256:3406b992b2c05f27b398a81375082a72aa2a823fd82616e4f8cb6f2a24370bb3 # kubeadm init 初始化完成会打印到console 上 # 可以通过 kubeadm token create --print-join-command 查看 "},{"id":4,"href":"/docs/kubernetes/operate/","title":"operate","section":"Kubernetes","content":"欢迎使用kubernetes\n"},{"id":5,"href":"/docs/%E7%9B%91%E6%8E%A7/prometheus/%E6%BA%90%E7%A0%81/","title":"operate","section":"prometheus","content":" prometheus 源码解读 # "},{"id":6,"href":"/docs/%E7%9B%91%E6%8E%A7/prometheus/","title":"prometheus","section":"监控","content":" prometheus 源码解读 # "},{"id":7,"href":"/docs/kubernetes/operate/%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%97%A0%E7%8A%B6%E6%80%81%E6%9C%8D%E5%8A%A1kubernetes%E7%9A%84%E5%86%85%E9%83%A8%E6%B5%81%E7%A8%8B/","title":"创建一个无状态服务","section":"operate","content":" 创建一个deployment资源 # 当创建一个deployment时，kubernetes 内部是如何处理的？\n创建 Deployment 资源 用户通过 kubectl apply 或 API 直接创建一个 Deployment 资源。 kube-apiserver 接收到请求后，将 Deployment 对象写入 etcd 数据库。 controller-manager 处理 Deployment kube-controller-manager 监听 Deployment 资源（通过 watch 机制）。 发现新建的 Deployment，DeploymentController 计算出需要创建的 ReplicaSet（如果是更新，还会进行滚动升级）。 controller-manager 通过 kube-apiserver 创建 ReplicaSet 资源。 controller-manager 处理 ReplicaSet kube-controller-manager 监听 ReplicaSet 资源（通过 watch 机制）。 发现新建的 ReplicaSet，ReplicaSetController 计算出需要创建的 Pod。 controller-manager 通过 kube-apiserver 创建 Pod 资源。 kube-scheduler 进行调度 kube-scheduler 监听 Pod 资源的变更（通过 watch 机制）。 发现 Pod 处于 Pending 状态，调度器计算出合适的 Node（根据 CPU、内存、调度策略等）。 kube-scheduler 通过 kube-apiserver 更新 Pod 的 spec.nodeName，分配到合适的节点。 kubelet 负责拉起容器 kubelet 监听 kube-apiserver，发现被分配到自己节点的 Pod。 kubelet 通过 Container Runtime Interface (CRI) 执行： 创建网络（调用 CNI 插件，分配 IP）。 挂载存储（调用 CSI 插件，挂载 Volume）。 启动容器（调用 CRI，使用 containerd 或 Docker 等创建容器）。 kubelet 通过 kube-apiserver 更新 Pod 状态（Running）。 创建一个service资源 # kube-proxy 监听 kube-apiserver 上的 service 资源的创建： 当 kube-proxy 监视到新的服务资源（Service）时，它会根据 Service 中的标签（labels）来筛选出符合条件的 Pod。这些 Pod 是与该 Service 相关联的目标（后端）。通过这些信息，kube-proxy 创建一个 Endpoints 资源对象，指向这些 Pod。 kube-proxy 监听 endpoint 资源的变化： Endpoints 资源对象被创建或更新，kube-proxy 就会动态地根据新的 Endpoint 信息来修改其网络规则（如 iptables 或 ipvs）。 kube-proxy 根据 Endpoint 中的 Pod 地址创建或更新相应的 iptables 或 ipvs 规则，这样流量就可以通过正确的后端 Pod 进行路由。 "},{"id":8,"href":"/docs/kubernetes/develop/%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%97%A0%E7%8A%B6%E6%80%81%E6%9C%8D%E5%8A%A1kubernetes%E7%9A%84%E5%86%85%E9%83%A8%E6%B5%81%E7%A8%8B/","title":"创建一个无状态服务，kubernetes的内部流程","section":"develop","content":" 创建一个deployment资源 # 当创建一个deployment时，kubernetes 内部是如何处理的？\n创建 Deployment 资源 用户通过 kubectl apply 或 API 直接创建一个 Deployment 资源。 kube-apiserver 接收到请求后，将 Deployment 对象写入 etcd 数据库。 controller-manager 处理 Deployment kube-controller-manager 监听 Deployment 资源（通过 watch 机制）。 发现新建的 Deployment，DeploymentController 计算出需要创建的 ReplicaSet（如果是更新，还会进行滚动升级）。 controller-manager 通过 kube-apiserver 创建 ReplicaSet 资源。 controller-manager 处理 ReplicaSet kube-controller-manager 监听 ReplicaSet 资源（通过 watch 机制）。 发现新建的 ReplicaSet，ReplicaSetController 计算出需要创建的 Pod。 controller-manager 通过 kube-apiserver 创建 Pod 资源。 kube-scheduler 进行调度 kube-scheduler 监听 Pod 资源的变更（通过 watch 机制）。 发现 Pod 处于 Pending 状态，调度器计算出合适的 Node（根据 CPU、内存、调度策略等）。 kube-scheduler 通过 kube-apiserver 更新 Pod 的 spec.nodeName，分配到合适的节点。 kubelet 负责拉起容器 kubelet 监听 kube-apiserver，发现被分配到自己节点的 Pod。 kubelet 通过 Container Runtime Interface (CRI) 执行： 创建网络（调用 CNI 插件，分配 IP）。 挂载存储（调用 CSI 插件，挂载 Volume）。 启动容器（调用 CRI，使用 containerd 或 Docker 等创建容器）。 kubelet 通过 kube-apiserver 更新 Pod 状态（Running）。 创建一个service资源 # kube-proxy 监听 kube-apiserver 上的 service 资源的创建： 当 kube-proxy 监视到新的服务资源（Service）时，它会根据 Service 中的标签（labels）来筛选出符合条件的 Pod。这些 Pod 是与该 Service 相关联的目标（后端）。通过这些信息，kube-proxy 创建一个 Endpoints 资源对象，指向这些 Pod。 kube-proxy 监听 endpoint 资源的变化： Endpoints 资源对象被创建或更新，kube-proxy 就会动态地根据新的 Endpoint 信息来修改其网络规则（如 iptables 或 ipvs）。 kube-proxy 根据 Endpoint 中的 Pod 地址创建或更新相应的 iptables 或 ipvs 规则，这样流量就可以通过正确的后端 Pod 进行路由。 "},{"id":9,"href":"/docs/%E7%9B%91%E6%8E%A7/","title":"监控","section":"文档首页","content":"欢迎使用prometheus\n"},{"id":10,"href":"/docs/%E7%AE%97%E6%B3%95/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/","title":"贪心算法","section":"算法","content":"本章节介绍贪心算法\n基本思想 # 局部最优解：在每一步决策中，选择当前状态下最优的局部解 无后效性：当前的选择不会影响后续的选择，即不依赖于未来的选择 希望导致全局最优解：通过一系列局部最优解，最终得到全局最优解 适用条件 # 贪心选择性质：问题的全局最优解可以通过一系列局部最优选择得到 最优子结构：问题的最优解包含子问题的最优解 步骤 # 问题分解：将问题分为若干个子问题 局部最优选择：对每个子问题，选择一个局部最优解 合并解：将局部最优解合并为全局解 经典应用 # 活动选择问题：选择最多的互不重叠的活动。 霍夫曼编码：构造最优前缀编码。 最小生成树：如Prim算法和Kruskal算法。 最短路径问题：如Dijkstra算法。 背包问题的分数版本：选择单位价值最高的物品。 优缺点 # 优点\n简单易实现 通常具有较高的效率 缺点 不总是能得到全局最优解 需要问题具有贪心选择性质和最优子结构 "},{"id":11,"href":"/docs/","title":"文档首页","section":"bei的个人博客","content":" 欢迎使用 Hugo Book 主题！ # "},{"id":12,"href":"/docs/%E7%9B%91%E6%8E%A7/prometheus/operator/","title":"源码","section":"prometheus","content":" prometheus 源码解读 # "},{"id":13,"href":"/docs/kubernetes/operate/install/calico/","title":"calico","section":"install","content":"xxx\n"},{"id":14,"href":"/docs/kubernetes/develop/","title":"develop","section":"Kubernetes","content":"欢迎使用kubernetes\n"},{"id":15,"href":"/docs/kubernetes/","title":"Kubernetes","section":"文档首页","content":"欢迎使用kubernetes\n"},{"id":16,"href":"/docs/%E7%9B%91%E6%8E%A7/thanos/","title":"Thanos","section":"监控","content":"欢迎使用thanos\n"},{"id":17,"href":"/docs/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","title":"动态规划","section":"算法","content":"本章节介绍贪心算法\n基本原理 # 最优子结构 一个问题的最优解包含其子问题的最优解，换句话说，问题的最优解可以通过子问题的最优解推到出来 重叠子问题 在求解过程中，子问题会被多次重复计算，动态规划通过存储子问题的解（通常使用表格或数组），避免重复计算 适用条件 # 最优化问题： 背包问题（0-1 背包、完全背包） 最短路径问题（Floyd-Warshall 算法） 最长公共子序列（LCS） 最大子数组和 计数问题： 组合数问题 路径计数问题 序列问题： 斐波那契数列 编辑距离（Levenshtein 距离） 步骤 # 定义状态 明确问题的状态表示，通常一个或多个变量描述问题的子问题 确定状态转移方程 找到状态之间的关系，即如何从子问题的解推导出当前问题的解 初始化 确定初始状态的值，通常问题的最小规模情况 计算顺序 按照一定的顺序计算状态，通常是自底向上（从最小子问题开始）或自顶向下（递归 + 记忆化） 返回结果 根据状态或数组返回最终问题的解 优化 # 空间优化： 如果状态转移方程只依赖于前一个状态，可以使用滚动数组或变量来减少空间复杂度。 例如：斐波那契数列问题可以优化为只使用两个变量。 记忆化搜索： 自顶向下的递归方法，通过缓存子问题的解来避免重复计算。 "},{"id":18,"href":"/docs/kubernetes/operate/install/argo/","title":"argo","section":"install","content":"xxx\n"},{"id":19,"href":"/docs/%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF/","title":"回溯","section":"算法","content":"本章节介绍贪心算法\n基本思想 # 局部最优解：在每一步决策中，选择当前状态下最优的局部解 无后效性：当前的选择不会影响后续的选择，即不依赖于未来的选择 希望导致全局最优解：通过一系列局部最优解，最终得到全局最优解 适用条件 # 贪心选择性质：问题的全局最优解可以通过一系列局部最优选择得到 最优子结构：问题的最优解包含子问题的最优解 步骤 # 问题分解：将问题分为若干个子问题 局部最优选择：对每个子问题，选择一个局部最优解 合并解：将局部最优解合并为全局解 经典应用 # 活动选择问题：选择最多的互不重叠的活动。 霍夫曼编码：构造最优前缀编码。 最小生成树：如Prim算法和Kruskal算法。 最短路径问题：如Dijkstra算法。 背包问题的分数版本：选择单位价值最高的物品。 优缺点 # 优点\n简单易实现 通常具有较高的效率 缺点 不总是能得到全局最优解 需要问题具有贪心选择性质和最优子结构 "},{"id":20,"href":"/docs/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/first/","title":"跳跃游戏 2","section":"动态规划","content":" 跳跃游戏 2 # leetcode 45\nfunc jump(nums []int) int { n := len(nums) if n \u0026lt;= 1{ return 0 } steps , curEnd, maxReach := 0, 0, 0 for i :=0 ; i\u0026lt; n ; i ++{ maxReach = max(maxReach, i + nums[i]) if i == curEnd{ steps ++ curEnd = maxReach if curEnd \u0026gt;= n-1{ break } } } return steps } "},{"id":21,"href":"/docs/%E7%AE%97%E6%B3%95/%E5%8F%8C%E6%8C%87%E9%92%88/first/","title":"跳跃游戏 2","section":"双指针","content":" 跳跃游戏 2 # leetcode 45\nfunc jump(nums []int) int { n := len(nums) if n \u0026lt;= 1{ return 0 } steps , curEnd, maxReach := 0, 0, 0 for i :=0 ; i\u0026lt; n ; i ++{ maxReach = max(maxReach, i + nums[i]) if i == curEnd{ steps ++ curEnd = maxReach if curEnd \u0026gt;= n-1{ break } } } return steps } "},{"id":22,"href":"/docs/%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF/first/","title":"跳跃游戏 2","section":"回溯","content":" 跳跃游戏 2 # leetcode 45\nfunc jump(nums []int) int { n := len(nums) if n \u0026lt;= 1{ return 0 } steps , curEnd, maxReach := 0, 0, 0 for i :=0 ; i\u0026lt; n ; i ++{ maxReach = max(maxReach, i + nums[i]) if i == curEnd{ steps ++ curEnd = maxReach if curEnd \u0026gt;= n-1{ break } } } return steps } "},{"id":23,"href":"/docs/%E7%AE%97%E6%B3%95/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/first/","title":"跳跃游戏 2","section":"贪心算法","content":" 跳跃游戏 2 # leetcode 45\nfunc jump(nums []int) int { n := len(nums) if n \u0026lt;= 1{ return 0 } steps , curEnd, maxReach := 0, 0, 0 for i :=0 ; i\u0026lt; n ; i ++{ maxReach = max(maxReach, i + nums[i]) if i == curEnd{ steps ++ curEnd = maxReach if curEnd \u0026gt;= n-1{ break } } } return steps } "},{"id":24,"href":"/docs/%E7%AE%97%E6%B3%95/%E5%8F%8C%E6%8C%87%E9%92%88/","title":"双指针","section":"算法","content":"本章节介绍贪心算法\n基本思想 # 局部最优解：在每一步决策中，选择当前状态下最优的局部解 无后效性：当前的选择不会影响后续的选择，即不依赖于未来的选择 希望导致全局最优解：通过一系列局部最优解，最终得到全局最优解 适用条件 # 贪心选择性质：问题的全局最优解可以通过一系列局部最优选择得到 最优子结构：问题的最优解包含子问题的最优解 步骤 # 问题分解：将问题分为若干个子问题 局部最优选择：对每个子问题，选择一个局部最优解 合并解：将局部最优解合并为全局解 经典应用 # 活动选择问题：选择最多的互不重叠的活动。 霍夫曼编码：构造最优前缀编码。 最小生成树：如Prim算法和Kruskal算法。 最短路径问题：如Dijkstra算法。 背包问题的分数版本：选择单位价值最高的物品。 优缺点 # 优点\n简单易实现 通常具有较高的效率 缺点 不总是能得到全局最优解 需要问题具有贪心选择性质和最优子结构 "}]