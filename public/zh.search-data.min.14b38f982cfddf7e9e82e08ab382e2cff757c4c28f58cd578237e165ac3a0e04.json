[{"id":0,"href":"/docs/%E7%9B%91%E6%8E%A7/prometheus/questions/01/","title":"01","section":"questions","content":" 如何在kubernetes中如何抓取服务的metrics # prometheus 中自带的几个metrics # prometheus 如何将数据发送给远端存储 # 介绍一下prometheus WAL 机制 # prometheus 使用什么压缩算法压缩数据 # "},{"id":1,"href":"/docs/kubernetes/develop/client-go/","title":"client-go","section":"develop","content":"欢迎使用client-go\n"},{"id":2,"href":"/docs/%E7%9B%91%E6%8E%A7/prometheus/develop/","title":"develop","section":"prometheus","content":" prometheus 源码解读 # "},{"id":3,"href":"/docs/go/first/","title":"First","section":"Go","content":" Golang的基本介绍 # "},{"id":4,"href":"/docs/go/","title":"Go","section":"文档首页","content":"本章节介绍 Hugo 的基本使用。\n"},{"id":5,"href":"/docs/kubernetes/develop/client-go/informer/","title":"informer","section":"client-go","content":" "},{"id":6,"href":"/docs/kubernetes/operate/install/","title":"install","section":"operate","content":"欢迎使用kubernetes\n"},{"id":7,"href":"/docs/%E7%9B%91%E6%8E%A7/prometheus/operator/install/","title":"install","section":"operator","content":" prometheus 源码解读 # "},{"id":8,"href":"/docs/kubernetes/operate/install/kubernetes/","title":"kubernetes","section":"install","content":" 部署前准备 # 修改机器名 hostnamectl set-hostname master 关闭swap swapoff -a sed -i \u0026#39;/swap / s/^\\(.*\\)$/#\\1/g\u0026#39; /etc/fstab free -m # 检查是否关闭swap ssh允许Root 登陆 vim /etc/ssh/sshd_config 增加 Port 22 PermitRootLogin yes passwd # 设置root 密码 关闭防火墙 sudo ufw disable 修改apt 源地址 cp /etc/apt/sources.list /etc/apt/sources.list.bak # 使用vim 替换/etc/apt/sources.list中的资源地址 vim /etc/apt/sources.list deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse # 更新 vim /etc/resolv.conf # 添加一下两行 nameserver 8.8.8.8 nameserver 8.8.4.4 apt-get update 添加 Kubernetes apt 存储库 sudo tee /etc/apt/sources.list.d/kubernetes.list \u0026lt;\u0026lt;-\u0026#39;EOF\u0026#39; deb https://mirrors.aliyun.com/kubernetes/apt kubernetes-xenial main EOF apt-get update The following signatures couldn\u0026#39;t be verified because the public key is not available: NO_PUBKEY B53DC80D13EDEF05 NO_PUBKEY FEEA9169307EA071 # 如果报错以上错误，执行下面一条命令 recv-keys 是报错现实的NO_PUBKEY sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys FEEA9169307EA071 安装kubectl kubeadm kubelet sudo apt-get install -y kubelet=1.22.2-00 kubeadm=1.22.2-00 kubectl=1.22.2-00 安装docker apt-get install -y docker.io systemctl enable docker master # 安装master 节点 kubeadm init \\ --apiserver-advertise-address=192.168.31.239 \\ --image-repository registry.aliyuncs.com/google_containers \\ --kubernetes-version v1.22.0 \\ --service-cidr=10.96.0.0/12 \\ --pod-network-cidr=10.244.0.0/16 node # 安装node 节点 kubeadm join 192.168.31.208:6443 --token u1soc8.1xyeqbzptpvvjz8f --discovery-token-ca-cert-hash sha256:3406b992b2c05f27b398a81375082a72aa2a823fd82616e4f8cb6f2a24370bb3 # kubeadm init 初始化完成会打印到console 上 # 可以通过 kubeadm token create --print-join-command 查看 "},{"id":9,"href":"/docs/%E7%9B%91%E6%8E%A7/prometheus/operator/install/kubernetes-services/","title":"kubernetes service","section":"install","content":"scrape_configs: - job_name: \u0026#39;kubernetes-pods\u0026#39; kubernetes_sd_configs: - role: pod relabel_configs: # 提取 annotation 中的 metrics_path - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_path] action: replace target_label: __metrics_path__ # 提取 annotation 中的 scrape interval - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_scrape_interval] action: replace target_label: scrape_interval # 提取 annotation 中的 scrape timeout - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_scrape_timeout] action: replace target_label: scrape_timeout # 通过 annotation 设置是否启用 scrape - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_scrape] action: keep regex: \u0026#34;true\u0026#34; # 提取 annotation 中的 metrics 端口 - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_port] action: replace target_label: __address__ regex: (.+) replacement: $1 apiVersion: v1 kind: Pod metadata: name: example-app annotations: prometheus.io/scrape: \u0026#34;true\u0026#34; prometheus.io/path: \u0026#34;/metrics\u0026#34; prometheus.io/port: \u0026#34;8080\u0026#34; prometheus.io/scrape_interval: \u0026#34;15s\u0026#34; prometheus.io/scrape_timeout: \u0026#34;10s\u0026#34; spec: containers: - name: example image: example-app ports: - containerPort: 8080 "},{"id":10,"href":"/docs/kubernetes/operate/","title":"operate","section":"Kubernetes","content":"欢迎使用kubernetes\n"},{"id":11,"href":"/docs/%E7%9B%91%E6%8E%A7/prometheus/operator/","title":"operator","section":"prometheus","content":" prometheus 源码解读 # "},{"id":12,"href":"/docs/%E7%9B%91%E6%8E%A7/prometheus/","title":"prometheus","section":"监控","content":"prometheus 架构图\n"},{"id":13,"href":"/docs/%E7%9B%91%E6%8E%A7/prometheus/operator/install/prometheus/","title":"prometheus","section":"install","content":" prometheus 的安装 # 使用 kube-prometheus 安装\n组件 # prometheus-adpter prometheus-operator alertmanager blackbox-exporter grafana prometheus kube-state-metrics node-exporter kubernetetsControllerPlan "},{"id":14,"href":"/docs/%E7%9B%91%E6%8E%A7/prometheus/develop/source-code/","title":"prometheus source code","section":"develop","content":" 模块列表 # discoveryManagerScrape 服务发现 scrapeManager queryEngine ruleManager discoveryManagerNotify notifierManager tracingManager "},{"id":15,"href":"/docs/kubernetes/questions/%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%97%A0%E7%8A%B6%E6%80%81%E6%9C%8D%E5%8A%A1kubernetes%E7%9A%84%E5%86%85%E9%83%A8%E6%B5%81%E7%A8%8B/","title":"创建一个无状态服务","section":"questions","content":" 创建一个deployment资源 # 当创建一个deployment时，kubernetes 内部是如何处理的？\n创建 Deployment 资源 用户通过 kubectl apply 或 API 直接创建一个 Deployment 资源。 kube-apiserver 接收到请求后，将 Deployment 对象写入 etcd 数据库。 controller-manager 处理 Deployment kube-controller-manager 监听 Deployment 资源（通过 watch 机制）。 发现新建的 Deployment，DeploymentController 计算出需要创建的 ReplicaSet（如果是更新，还会进行滚动升级）。 controller-manager 通过 kube-apiserver 创建 ReplicaSet 资源。 controller-manager 处理 ReplicaSet kube-controller-manager 监听 ReplicaSet 资源（通过 watch 机制）。 发现新建的 ReplicaSet，ReplicaSetController 计算出需要创建的 Pod。 controller-manager 通过 kube-apiserver 创建 Pod 资源。 kube-scheduler 进行调度 kube-scheduler 监听 Pod 资源的变更（通过 watch 机制）。 发现 Pod 处于 Pending 状态，调度器计算出合适的 Node（根据 CPU、内存、调度策略等）。 kube-scheduler 通过 kube-apiserver 更新 Pod 的 spec.nodeName，分配到合适的节点。 kubelet 负责拉起容器 kubelet 监听 kube-apiserver，发现被分配到自己节点的 Pod。 kubelet 通过 Container Runtime Interface (CRI) 执行： 创建网络（调用 CNI 插件，分配 IP）。 挂载存储（调用 CSI 插件，挂载 Volume）。 启动容器（调用 CRI，使用 containerd 或 Docker 等创建容器）。 kubelet 通过 kube-apiserver 更新 Pod 状态（Running）。 创建一个service资源 # kube-proxy 监听 kube-apiserver 上的 service 资源的创建： 当 kube-proxy 监视到新的服务资源（Service）时，它会根据 Service 中的标签（labels）来筛选出符合条件的 Pod。这些 Pod 是与该 Service 相关联的目标（后端）。通过这些信息，kube-proxy 创建一个 Endpoints 资源对象，指向这些 Pod。 kube-proxy 监听 endpoint 资源的变化： Endpoints 资源对象被创建或更新，kube-proxy 就会动态地根据新的 Endpoint 信息来修改其网络规则（如 iptables 或 ipvs）。 kube-proxy 根据 Endpoint 中的 Pod 地址创建或更新相应的 iptables 或 ipvs 规则，这样流量就可以通过正确的后端 Pod 进行路由。 "},{"id":16,"href":"/docs/%E7%AE%97%E6%B3%95/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/","title":"贪心算法","section":"算法","content":"本章节介绍贪心算法\n基本思想 # 局部最优解：在每一步决策中，选择当前状态下最优的局部解 无后效性：当前的选择不会影响后续的选择，即不依赖于未来的选择 希望导致全局最优解：通过一系列局部最优解，最终得到全局最优解 适用条件 # 贪心选择性质：问题的全局最优解可以通过一系列局部最优选择得到 最优子结构：问题的最优解包含子问题的最优解 步骤 # 问题分解：将问题分为若干个子问题 局部最优选择：对每个子问题，选择一个局部最优解 合并解：将局部最优解合并为全局解 经典应用 # 活动选择问题：选择最多的互不重叠的活动。 霍夫曼编码：构造最优前缀编码。 最小生成树：如Prim算法和Kruskal算法。 最短路径问题：如Dijkstra算法。 背包问题的分数版本：选择单位价值最高的物品。 优缺点 # 优点\n简单易实现 通常具有较高的效率 缺点 不总是能得到全局最优解 需要问题具有贪心选择性质和最优子结构 "},{"id":17,"href":"/docs/","title":"文档首页","section":"bei的个人博客","content":" 欢迎使用 Hugo Book 主题！ # "},{"id":18,"href":"/docs/kubernetes/operate/install/calico/","title":"calico","section":"install","content":"xxx\n"},{"id":19,"href":"/docs/kubernetes/develop/controller-runtime/","title":"controller runtime","section":"develop","content":"欢迎使用controller runtime\n"},{"id":20,"href":"/docs/kubernetes/develop/","title":"develop","section":"Kubernetes","content":"欢迎使用kubernetes\n"},{"id":21,"href":"/docs/kubernetes/","title":"Kubernetes","section":"文档首页","content":"kubernetes 架构图\n"},{"id":22,"href":"/docs/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","title":"动态规划","section":"算法","content":"本章节介绍贪心算法\n基本原理 # 最优子结构 一个问题的最优解包含其子问题的最优解，换句话说，问题的最优解可以通过子问题的最优解推到出来 重叠子问题 在求解过程中，子问题会被多次重复计算，动态规划通过存储子问题的解（通常使用表格或数组），避免重复计算 适用条件 # 最优化问题： 背包问题（0-1 背包、完全背包） 最短路径问题（Floyd-Warshall 算法） 最长公共子序列（LCS） 最大子数组和 计数问题： 组合数问题 路径计数问题 序列问题： 斐波那契数列 编辑距离（Levenshtein 距离） 步骤 # 定义状态 明确问题的状态表示，通常一个或多个变量描述问题的子问题 确定状态转移方程 找到状态之间的关系，即如何从子问题的解推导出当前问题的解 初始化 确定初始状态的值，通常问题的最小规模情况 计算顺序 按照一定的顺序计算状态，通常是自底向上（从最小子问题开始）或自顶向下（递归 + 记忆化） 返回结果 根据状态或数组返回最终问题的解 优化 # 空间优化： 如果状态转移方程只依赖于前一个状态，可以使用滚动数组或变量来减少空间复杂度。 例如：斐波那契数列问题可以优化为只使用两个变量。 记忆化搜索： 自顶向下的递归方法，通过缓存子问题的解来避免重复计算。 "},{"id":23,"href":"/docs/kubernetes/operate/%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BAkubeconfig/","title":"如何创建kubeConfig","section":"operate","content":" 如何创建kubeConfig # 创建clusterRole kubectl create clusterrole monitor --resource=prometheusrule --verb=\u0026#34;*\u0026#34; 创建clusterRoleBinding kubectl create clusterrolebinding monitor --clusterrole=rule --user monitor 生成普通用户令牌 cd /etc/kubernetes/pki #你的集群证书目录 user=monitor organization=monitoring clustername=cluster02 # 【集群地址，例如：https://172.21.114.169:6443】 api_addr=https://192.168.31.208:6443 time_days=365 #复制粘贴下面的代码即可 umask 077;openssl genrsa -out $user.key 2048 openssl req -new -key $user.key -out $user.csr -subj \u0026#34;/O=$organization/CN=$user\u0026#34; openssl x509 -req -in $user.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out $user.crt -days $time_days kubectl config set-cluster $clustername --server=$api_addr --certificate-authority=ca.crt --embed-certs=true --kubeconfig=/root/$user.config kubectl config set-credentials $user --client-certificate=$user.crt --client-key=$user.key --embed-certs=true --kubeconfig=/root/$user.config kubectl config set-context $user@$clustername --cluster=$clustername --user=$user --kubeconfig=/root/$user.config kubectl config use-context $user@$clustername --kubeconfig=/root/$user.config "},{"id":24,"href":"/docs/kubernetes/operate/install/argo/","title":"argo","section":"install","content":"xxx\n"},{"id":25,"href":"/docs/kubernetes/questions/","title":"questions","section":"Kubernetes","content":"本人介绍kubernetes 常见的问题\n"},{"id":26,"href":"/docs/%E7%9B%91%E6%8E%A7/prometheus/questions/","title":"questions","section":"prometheus","content":"本人介绍prometheus 常见的问题\n"},{"id":27,"href":"/docs/%E7%9B%91%E6%8E%A7/thanos/","title":"questions","section":"监控","content":" "},{"id":28,"href":"/docs/kubernetes/reources/","title":"resources","section":"Kubernetes","content":" Group、Version、Resource 核心数据结构 # 整个Kubernetes 体系架构中，资源是Kubernetes最重要的概念，可以说Kubernets的生态系统都围绕着资源运作。\nKubernetes系统虽然有相当复杂和众多的功能，但是它本质上是一个资源控制系统——注册、管理、调度资源并维护资源的状态\nKubernetes 将资源分组和版本化，形成Group（资源组）、Version（资源版本）、Resource（资源）\nGroup：资源组，在Kubernetes API Server 中也可称其为APIGroup Version：资源版本，在Kubernets API Server 中也可称其为APIVersions Resource：资源，在Kubernetes API Server 中也可称其为APIResource Kind：资源种类，描述Resource 的种类，与Resource为同一级别 Kubernetes 系统支持多个Group。每个Group支持多个Version，每个Version支持多个Resource，同时部分资源会拥有自己的子资源\n资源组、资源版本、资源、子资源的完整表达形式为\u0026lt;group\u0026gt;/\u0026lt;version\u0026gt;/\u0026lt;resource\u0026gt;/\u0026lt;status\u0026gt;,以常用的Deployment资源为例，其完整表现形式为apps/v1/deployments/status\n资源对象由 资源组 + 资源版本 + 资源种类组成，例如Deployment 资源是实例化后拥有资源组、资源版本及资源种类，其表现形式为/,Kind=,例如apps/v1，Kind= Deployment\n每一个资源都拥有一定数量的资源操作方法（即Verbs），资源操作方法用于Etcd集群存储中对资源对象的增、删、改、查操作。目前Kubernetes系统支持8种资源操作方法，分别是create、delete、deletecollection、get、list、patch、update、watch操作方法\nKubernetes的资源也分两种，分别是Kubernetes Resource（kubernetes 内置资源） 和 Custom Resource（自定义资源）。开发者通过CRD（即Custom Resource Definitions）可实现自定义资源，它允许用户将自己定义的资源添加到Kubenetes 系统中，并像使用kubernetes 内置资源一样使用它们\n"},{"id":29,"href":"/docs/%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF/","title":"回溯","section":"算法","content":"本章节介绍回溯方法\n基本思想 # 尝试构建解（探索） 如果不满足条件，则回退（回溯） 如果满足条件，则记录解 步骤 # 选择（Choose）：尝试做出选择，向解空间深处探索。 约束（Constraint）：检查当前选择是否满足问题约束条件，若不满足则回退。 撤销（Unchoose）：如果该选择导致后续无解，则撤销选择，回到上一步。 优缺点 # 优点\n易于实现：代码结构清晰，递归思维自然适配回溯法。 能求所有解：适用于组合、排列、子集问题，能遍历所有可能方案。 适用于树形结构问题：如决策树、DFS 搜索路径。 可以结合剪枝优化：如 used[] 记录状态、提前终止无效搜索。 缺点 时间复杂度高： 组合：O(C(n, k)) ≈ 指数级 排列：O(n!)（非常高） 迷宫：最坏 O(4^n)（四个方向尝试） 重复计算： 例如编辑距离计算，回溯会重复计算子问题，导致超时。 优化：记忆化搜索 + 剪枝。 不适合大规模数据： 搜索空间太大时，直接超时！ 需要优化，如 剪枝、DP 代替回溯。 "},{"id":30,"href":"/docs/%E7%AE%97%E6%B3%95/%E5%8F%8C%E6%8C%87%E9%92%88/first/","title":"跳跃游戏 2","section":"双指针","content":" 跳跃游戏 2 # leetcode 45\nfunc jump(nums []int) int { n := len(nums) if n \u0026lt;= 1{ return 0 } steps , curEnd, maxReach := 0, 0, 0 for i :=0 ; i\u0026lt; n ; i ++{ maxReach = max(maxReach, i + nums[i]) if i == curEnd{ steps ++ curEnd = maxReach if curEnd \u0026gt;= n-1{ break } } } return steps } "},{"id":31,"href":"/docs/%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF/first/","title":"跳跃游戏 2","section":"回溯","content":" 跳跃游戏 2 # leetcode 45\nfunc jump(nums []int) int { n := len(nums) if n \u0026lt;= 1{ return 0 } steps , curEnd, maxReach := 0, 0, 0 for i :=0 ; i\u0026lt; n ; i ++{ maxReach = max(maxReach, i + nums[i]) if i == curEnd{ steps ++ curEnd = maxReach if curEnd \u0026gt;= n-1{ break } } } return steps } "},{"id":32,"href":"/docs/%E7%AE%97%E6%B3%95/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/first/","title":"跳跃游戏 2","section":"贪心算法","content":" 跳跃游戏 2 # leetcode 45\nfunc jump(nums []int) int { n := len(nums) if n \u0026lt;= 1{ return 0 } steps , curEnd, maxReach := 0, 0, 0 for i :=0 ; i\u0026lt; n ; i ++{ maxReach = max(maxReach, i + nums[i]) if i == curEnd{ steps ++ curEnd = maxReach if curEnd \u0026gt;= n-1{ break } } } return steps } "},{"id":33,"href":"/docs/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/first/","title":"最长公共子序列","section":"动态规划","content":" 跳跃游戏 2 # leetcode 45\n给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。\n一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。\n例如，\u0026ldquo;ace\u0026rdquo; 是 \u0026ldquo;abcde\u0026rdquo; 的子序列，但 \u0026ldquo;aec\u0026rdquo; 不是 \u0026ldquo;abcde\u0026rdquo; 的子序列。 两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。\nfunc longestCommonSubsequence(text1 string, text2 string) int { m, n := len(text1), len(text2) dp := make([][]int, m+1) for i := range dp { dp[i] = make([]int, n+1) } for i := 1; i \u0026lt;= m; i++ { for j := 1; j \u0026lt;= n; j++ { if text1[i-1] == text2[j-1] { dp[i][j] = dp[i-1][j-1] + 1 } else { dp[i][j] = max(dp[i-1][j], dp[i][j-1]) } } } return dp[m][n] } "},{"id":34,"href":"/docs/%E7%AE%97%E6%B3%95/%E5%8F%8C%E6%8C%87%E9%92%88/","title":"双指针","section":"算法","content":"本章节介绍双指针\n基本思想 # 双指针（Two Pointers） 是一种常用的算法优化技巧，通过两个指针（索引）在数组或链表上进行遍历，减少不必要的重复计算，提高效率。 适用于 数组、字符串、链表等线性结构，\n查找 比较 去重 排序等。 适用条件 # 有序数组/字符串/链表，方便利用 左右对撞 或 快慢遍历。 寻找特定组合（如和为 target），可以通过 对撞指针 避免暴力解法。 需要动态维护窗口（如最长无重复子串），滑动窗口可高效解决问题。 步骤 # 问题分解：将问题分为若干个子问题 局部最优选择：对每个子问题，选择一个局部最优解 合并解：将局部最优解合并为全局解 经典应用 # 活动选择问题：选择最多的互不重叠的活动。 霍夫曼编码：构造最优前缀编码。 最小生成树：如Prim算法和Kruskal算法。 最短路径问题：如Dijkstra算法。 背包问题的分数版本：选择单位价值最高的物品。 优缺点 # 优点\n降低时间复杂度 套循环，降低 O(n²) 为 O(n)，减少不必要的计算。 适用于有序结构 有序数组、单调递增序列 可用双指针 高效查找目标值。 空间复杂度低 一般只需 O(1) 额外空间，避免额外数组或哈希表。 缺点\n不适用于无序数组 例如 无序数组求和 不能直接用 对撞指针。 有些问题无法规避嵌套循环 例如 四数之和 仍然需要 O(n³)。 复杂情况需要额外逻辑 滑动窗口有时候需要 哈希表 记录状态。 "},{"id":35,"href":"/docs/%E7%AE%97%E6%B3%95/%E5%A0%86/","title":"堆","section":"算法","content":"本章节介绍堆\n基本思想 # 堆通常用完全二叉树实现，并存储在数组中，保证高效的插入和删除操作 最大堆：每个节点的值都大于等于其子节点的值，根节点是最大值 最小堆：每个节点的值都小于其子节点的值，根节点是最小值 存储方式 # 使用数组表示完全二叉树 操作 # 插入操作\n把新元素插入到数组末尾 上浮 删除堆顶元素\n用最后一个元素替换堆顶 下沉 堆排序\n构建最大堆 交换根节点和最后一个元素 调整堆 重复上述步骤，直到排序完成 经典应用 # 优先队列（Priority Queue） 使用最小堆实现任务优先级调度 使用最大堆实现Top K 问题 求TOP K 大/小元素 最小堆求TOP K 大元素 最大堆求TOP K 小元素 中位数维护 左边最大堆（维护较小的一半数） 右边最小堆（维护较大的一半数） 中位数为两堆的顶元素 优缺点 # 优点\n插入、删除 操作时间复杂度 O(log n) 动态维护 Top K 问题，适用于大数据场景 优先队列实现简单高效 缺点\n不支持快速查找（不像哈希表 O(1)） 堆排序不是稳定排序（相同元素相对顺序可能改变） 数组实现堆可能需要额外的空间移动 示例 # 最小堆\nimport \u0026#34;container/heap\u0026#34; type MinHeap []int func (h MinHeap) Len() int { return len(h) } func (h MinHeap) Less(i, j int) bool { return h[i] \u0026lt; h[j] } // 最小堆 func (h MinHeap) Swap(i, j int) { h[i], h[j] = h[j], h[i] } func (h *MinHeap) Push(x any) { *h = append(*h, x.(int)) } func (h *MinHeap) Pop() any { old := *h n := len(old) x := old[n-1] *h = old[:n-1] return x } func main() { h := \u0026amp;MinHeap{} heap.Init(h) heap.Push(h, 5) heap.Push(h, 2) heap.Push(h, 8) heap.Push(h, 1) fmt.Println(heap.Pop(h)) // 1 } "},{"id":36,"href":"/docs/%E7%AE%97%E6%B3%95/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/","title":"拓扑排序","section":"算法","content":"本章节介绍堆\n基本思想 # 拓扑排序（Topological Sorting）是 针对有向无环图（DAG, Directed Acyclic Graph）的一种排序方法，它的目标是将图中的所有顶点排序，使得对于每一条有向边 (u → v)，顶点 u 先出现在 v 之前。\nkahn算法（入度法） 维护所有入度0的节点（可以入队） 每次从队列中取出一个节点，并删除它指向的边，更新相邻节点的入度 若某个相邻节点入度变成0，则加入队列 知道所有节点都被访问完 DFS 逆序法 采用DFS遍历每个点，递归访问所有子节点 访问完所有后续节点后，将当前的节点压入栈 最终栈中的元素顺序即为拓扑排序的结果 经典应用 # 任务调度 场景：多个任务有前后依赖关系，必须按顺序执行。 示例：编译多个源代码文件时，需要先编译依赖文件。 课程安排（先修课程） 场景：某些课程需要先完成前置课程，才能学习后续课程。 示例：LeetCode 207 课程表（Course Schedule）问题。 电路时序分析 场景：计算电路中信号的传播顺序，确保数据按逻辑流动。 软件包依赖管理 场景：如 npm、pip 等包管理器，安装包时需要先安装其依赖项。 编译器优化 场景：代码中的函数调用优化，确定依赖关系，减少重复计算。 优缺点 # 优点\n高效性： Kahn 算法 时间复杂度 O(V + E)（遍历所有节点和边）。 DFS 逆序法 时间复杂度也是 O(V + E)。 易于实现： 代码简单，适用于有向无环图（DAG）。 解决依赖关系问题： 能很好地解决 任务调度、先修课程、软件包管理 等依赖问题。 缺点\n仅适用于 DAG： 不能处理有环图，如果图中有环，无法进行拓扑排序。 可能有多种拓扑排序结果： 拓扑排序的结果可能不是唯一的，不同的算法可能得出不同的合法顺序。 不能检测所有依赖冲突： 仅能发现 循环依赖（环），但无法处理复杂的冲突（如并发依赖）。 "},{"id":37,"href":"/docs/%E7%AE%97%E6%B3%95/%E5%88%86%E6%B2%BB%E6%B3%95/","title":"分治法","section":"算法","content":"本章节介绍贪心算法\n基本思想 # 分解 将多个问题分成多个规模较小、相互独立的子问题 这些子问题的形式与原问题相似，但规模较小 解决 递归地求解这些子问题，直到问题的规模足够小，可以直接求解（通常较小规模的基本情况，如数组只有一个元素） 合并 将所有的子问题的解合并成原问题的解 经典应用 # 排序算法 归并排序（Merge Sort）：将数组拆分成两半，分别排序后合并。 快速排序（Quick Sort）：选择一个基准值（pivot），将数组划分为 小于基准值 和 大于基准值 的部分，然后递归排序。 计算数学 大整数乘法（Karatsuba算法）：将大整数拆分为较小的部分递归计算，提高乘法速度。 矩阵乘法（Strassen算法）：将矩阵拆分成更小的子矩阵，提高计算效率。 递归问题 汉诺塔问题：将问题分解为“移动 n-1 层盘子”的问题递归求解。 最大子数组和（分治法解法）：将数组拆分为左右两部分，求解最大子数组和。 计算几何 最近点对问题：将点集按 x 轴拆分，分别计算最近点对，然后合并结果。 凸包问题：使用分治法求解点集中凸包。 优缺点 # 优点\n易于理解和实现：递归思想清晰，代码结构往往简单直观。 高效：通常可以将问题的时间复杂度降至 O(n \\log n) 或更优，如 归并排序、快速排序。 适用于大规模问题：能够将复杂问题拆解成小问题，适用于 大数据处理。 并行计算：许多分治法算法可以 并行化（如 并行归并排序），提升执行效率。 缺点\n递归调用可能造成额外开销：如果递归深度过大，可能导致 栈溢出（Stack Overflow）。 额外的空间开销： 归并排序需要 额外的存储空间（O(n)）来存储合并后的结果。 快速排序（在原数组上进行，不需要额外空间）。 子问题可能不是完全独立的： 例如，动态规划 也使用递归，但存在 重叠子问题，需要通过 记忆化搜索（Memoization） 或 递推 进行优化。 "}]