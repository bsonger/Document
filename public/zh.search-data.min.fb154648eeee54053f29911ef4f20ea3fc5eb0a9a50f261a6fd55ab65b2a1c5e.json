[{"id":0,"href":"/docs/%E7%9B%91%E6%8E%A7/prometheus/develop/","title":"develop","section":"prometheus","content":" prometheus 源码解读 # "},{"id":1,"href":"/docs/go/first/","title":"First","section":"Go","content":" Golang的基本介绍 # "},{"id":2,"href":"/docs/go/","title":"Go","section":"文档首页","content":"本章节介绍 Hugo 的基本使用。\n"},{"id":3,"href":"/docs/kubernetes/operate/install/","title":"install","section":"operate","content":"欢迎使用kubernetes\n"},{"id":4,"href":"/docs/%E7%9B%91%E6%8E%A7/prometheus/develop/source-code/install/","title":"install","section":"operator","content":" prometheus 源码解读 # "},{"id":5,"href":"/docs/%E7%9B%91%E6%8E%A7/prometheus/operator/install/","title":"install","section":"operator","content":" prometheus 源码解读 # "},{"id":6,"href":"/docs/kubernetes/operate/install/kubernetes/","title":"kubernetes","section":"install","content":" 部署前准备 # 修改机器名 hostnamectl set-hostname master 关闭swap swapoff -a sed -i \u0026#39;/swap / s/^\\(.*\\)$/#\\1/g\u0026#39; /etc/fstab free -m # 检查是否关闭swap ssh允许Root 登陆 vim /etc/ssh/sshd_config 增加 Port 22 PermitRootLogin yes passwd # 设置root 密码 关闭防火墙 sudo ufw disable 修改apt 源地址 cp /etc/apt/sources.list /etc/apt/sources.list.bak # 使用vim 替换/etc/apt/sources.list中的资源地址 vim /etc/apt/sources.list deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse # 更新 vim /etc/resolv.conf # 添加一下两行 nameserver 8.8.8.8 nameserver 8.8.4.4 apt-get update 添加 Kubernetes apt 存储库 sudo tee /etc/apt/sources.list.d/kubernetes.list \u0026lt;\u0026lt;-\u0026#39;EOF\u0026#39; deb https://mirrors.aliyun.com/kubernetes/apt kubernetes-xenial main EOF apt-get update The following signatures couldn\u0026#39;t be verified because the public key is not available: NO_PUBKEY B53DC80D13EDEF05 NO_PUBKEY FEEA9169307EA071 # 如果报错以上错误，执行下面一条命令 recv-keys 是报错现实的NO_PUBKEY sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys FEEA9169307EA071 安装kubectl kubeadm kubelet sudo apt-get install -y kubelet=1.22.2-00 kubeadm=1.22.2-00 kubectl=1.22.2-00 安装docker apt-get install -y docker.io systemctl enable docker master # 安装master 节点 kubeadm init \\ --apiserver-advertise-address=192.168.31.239 \\ --image-repository registry.aliyuncs.com/google_containers \\ --kubernetes-version v1.22.0 \\ --service-cidr=10.96.0.0/12 \\ --pod-network-cidr=10.244.0.0/16 node # 安装node 节点 kubeadm join 192.168.31.208:6443 --token u1soc8.1xyeqbzptpvvjz8f --discovery-token-ca-cert-hash sha256:3406b992b2c05f27b398a81375082a72aa2a823fd82616e4f8cb6f2a24370bb3 # kubeadm init 初始化完成会打印到console 上 # 可以通过 kubeadm token create --print-join-command 查看 "},{"id":7,"href":"/docs/%E7%9B%91%E6%8E%A7/prometheus/develop/source-code/install/kubernetes-services/","title":"kubernetes service","section":"install","content":"scrape_configs: - job_name: \u0026#39;kubernetes-pods\u0026#39; kubernetes_sd_configs: - role: pod relabel_configs: # 提取 annotation 中的 metrics_path - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_path] action: replace target_label: __metrics_path__ # 提取 annotation 中的 scrape interval - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_scrape_interval] action: replace target_label: scrape_interval # 提取 annotation 中的 scrape timeout - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_scrape_timeout] action: replace target_label: scrape_timeout # 通过 annotation 设置是否启用 scrape - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_scrape] action: keep regex: \u0026#34;true\u0026#34; # 提取 annotation 中的 metrics 端口 - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_port] action: replace target_label: __address__ regex: (.+) replacement: $1 apiVersion: v1 kind: Pod metadata: name: example-app annotations: prometheus.io/scrape: \u0026#34;true\u0026#34; prometheus.io/path: \u0026#34;/metrics\u0026#34; prometheus.io/port: \u0026#34;8080\u0026#34; prometheus.io/scrape_interval: \u0026#34;15s\u0026#34; prometheus.io/scrape_timeout: \u0026#34;10s\u0026#34; spec: containers: - name: example image: example-app ports: - containerPort: 8080 "},{"id":8,"href":"/docs/%E7%9B%91%E6%8E%A7/prometheus/operator/install/kubernetes-services/","title":"kubernetes service","section":"install","content":"scrape_configs: - job_name: \u0026#39;kubernetes-pods\u0026#39; kubernetes_sd_configs: - role: pod relabel_configs: # 提取 annotation 中的 metrics_path - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_path] action: replace target_label: __metrics_path__ # 提取 annotation 中的 scrape interval - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_scrape_interval] action: replace target_label: scrape_interval # 提取 annotation 中的 scrape timeout - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_scrape_timeout] action: replace target_label: scrape_timeout # 通过 annotation 设置是否启用 scrape - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_scrape] action: keep regex: \u0026#34;true\u0026#34; # 提取 annotation 中的 metrics 端口 - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_port] action: replace target_label: __address__ regex: (.+) replacement: $1 apiVersion: v1 kind: Pod metadata: name: example-app annotations: prometheus.io/scrape: \u0026#34;true\u0026#34; prometheus.io/path: \u0026#34;/metrics\u0026#34; prometheus.io/port: \u0026#34;8080\u0026#34; prometheus.io/scrape_interval: \u0026#34;15s\u0026#34; prometheus.io/scrape_timeout: \u0026#34;10s\u0026#34; spec: containers: - name: example image: example-app ports: - containerPort: 8080 "},{"id":9,"href":"/docs/kubernetes/operate/","title":"operate","section":"Kubernetes","content":"欢迎使用kubernetes\n"},{"id":10,"href":"/docs/%E7%9B%91%E6%8E%A7/prometheus/develop/source-code/","title":"operator","section":"develop","content":" prometheus 源码解读 # "},{"id":11,"href":"/docs/%E7%9B%91%E6%8E%A7/prometheus/operator/","title":"operator","section":"prometheus","content":" prometheus 源码解读 # "},{"id":12,"href":"/docs/%E7%9B%91%E6%8E%A7/prometheus/","title":"prometheus","section":"监控","content":" prometheus 源码解读 # "},{"id":13,"href":"/docs/%E7%9B%91%E6%8E%A7/prometheus/develop/source-code/install/prometheus/","title":"prometheus","section":"install","content":" prometheus 的安装 # 使用 kube-prometheus 安装\n组件 # prometheus-adpter prometheus-operator alertmanager blackbox-exporter grafana prometheus kube-state-metrics node-exporter kubernetetsControllerPlan "},{"id":14,"href":"/docs/%E7%9B%91%E6%8E%A7/prometheus/operator/install/prometheus/","title":"prometheus","section":"install","content":" prometheus 的安装 # 使用 kube-prometheus 安装\n组件 # prometheus-adpter prometheus-operator alertmanager blackbox-exporter grafana prometheus kube-state-metrics node-exporter kubernetetsControllerPlan "},{"id":15,"href":"/docs/kubernetes/operate/%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%97%A0%E7%8A%B6%E6%80%81%E6%9C%8D%E5%8A%A1kubernetes%E7%9A%84%E5%86%85%E9%83%A8%E6%B5%81%E7%A8%8B/","title":"创建一个无状态服务","section":"operate","content":" 创建一个deployment资源 # 当创建一个deployment时，kubernetes 内部是如何处理的？\n创建 Deployment 资源 用户通过 kubectl apply 或 API 直接创建一个 Deployment 资源。 kube-apiserver 接收到请求后，将 Deployment 对象写入 etcd 数据库。 controller-manager 处理 Deployment kube-controller-manager 监听 Deployment 资源（通过 watch 机制）。 发现新建的 Deployment，DeploymentController 计算出需要创建的 ReplicaSet（如果是更新，还会进行滚动升级）。 controller-manager 通过 kube-apiserver 创建 ReplicaSet 资源。 controller-manager 处理 ReplicaSet kube-controller-manager 监听 ReplicaSet 资源（通过 watch 机制）。 发现新建的 ReplicaSet，ReplicaSetController 计算出需要创建的 Pod。 controller-manager 通过 kube-apiserver 创建 Pod 资源。 kube-scheduler 进行调度 kube-scheduler 监听 Pod 资源的变更（通过 watch 机制）。 发现 Pod 处于 Pending 状态，调度器计算出合适的 Node（根据 CPU、内存、调度策略等）。 kube-scheduler 通过 kube-apiserver 更新 Pod 的 spec.nodeName，分配到合适的节点。 kubelet 负责拉起容器 kubelet 监听 kube-apiserver，发现被分配到自己节点的 Pod。 kubelet 通过 Container Runtime Interface (CRI) 执行： 创建网络（调用 CNI 插件，分配 IP）。 挂载存储（调用 CSI 插件，挂载 Volume）。 启动容器（调用 CRI，使用 containerd 或 Docker 等创建容器）。 kubelet 通过 kube-apiserver 更新 Pod 状态（Running）。 创建一个service资源 # kube-proxy 监听 kube-apiserver 上的 service 资源的创建： 当 kube-proxy 监视到新的服务资源（Service）时，它会根据 Service 中的标签（labels）来筛选出符合条件的 Pod。这些 Pod 是与该 Service 相关联的目标（后端）。通过这些信息，kube-proxy 创建一个 Endpoints 资源对象，指向这些 Pod。 kube-proxy 监听 endpoint 资源的变化： Endpoints 资源对象被创建或更新，kube-proxy 就会动态地根据新的 Endpoint 信息来修改其网络规则（如 iptables 或 ipvs）。 kube-proxy 根据 Endpoint 中的 Pod 地址创建或更新相应的 iptables 或 ipvs 规则，这样流量就可以通过正确的后端 Pod 进行路由。 "},{"id":16,"href":"/docs/kubernetes/develop/%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%97%A0%E7%8A%B6%E6%80%81%E6%9C%8D%E5%8A%A1kubernetes%E7%9A%84%E5%86%85%E9%83%A8%E6%B5%81%E7%A8%8B/","title":"创建一个无状态服务，kubernetes的内部流程","section":"develop","content":" 创建一个deployment资源 # 当创建一个deployment时，kubernetes 内部是如何处理的？\n创建 Deployment 资源 用户通过 kubectl apply 或 API 直接创建一个 Deployment 资源。 kube-apiserver 接收到请求后，将 Deployment 对象写入 etcd 数据库。 controller-manager 处理 Deployment kube-controller-manager 监听 Deployment 资源（通过 watch 机制）。 发现新建的 Deployment，DeploymentController 计算出需要创建的 ReplicaSet（如果是更新，还会进行滚动升级）。 controller-manager 通过 kube-apiserver 创建 ReplicaSet 资源。 controller-manager 处理 ReplicaSet kube-controller-manager 监听 ReplicaSet 资源（通过 watch 机制）。 发现新建的 ReplicaSet，ReplicaSetController 计算出需要创建的 Pod。 controller-manager 通过 kube-apiserver 创建 Pod 资源。 kube-scheduler 进行调度 kube-scheduler 监听 Pod 资源的变更（通过 watch 机制）。 发现 Pod 处于 Pending 状态，调度器计算出合适的 Node（根据 CPU、内存、调度策略等）。 kube-scheduler 通过 kube-apiserver 更新 Pod 的 spec.nodeName，分配到合适的节点。 kubelet 负责拉起容器 kubelet 监听 kube-apiserver，发现被分配到自己节点的 Pod。 kubelet 通过 Container Runtime Interface (CRI) 执行： 创建网络（调用 CNI 插件，分配 IP）。 挂载存储（调用 CSI 插件，挂载 Volume）。 启动容器（调用 CRI，使用 containerd 或 Docker 等创建容器）。 kubelet 通过 kube-apiserver 更新 Pod 状态（Running）。 创建一个service资源 # kube-proxy 监听 kube-apiserver 上的 service 资源的创建： 当 kube-proxy 监视到新的服务资源（Service）时，它会根据 Service 中的标签（labels）来筛选出符合条件的 Pod。这些 Pod 是与该 Service 相关联的目标（后端）。通过这些信息，kube-proxy 创建一个 Endpoints 资源对象，指向这些 Pod。 kube-proxy 监听 endpoint 资源的变化： Endpoints 资源对象被创建或更新，kube-proxy 就会动态地根据新的 Endpoint 信息来修改其网络规则（如 iptables 或 ipvs）。 kube-proxy 根据 Endpoint 中的 Pod 地址创建或更新相应的 iptables 或 ipvs 规则，这样流量就可以通过正确的后端 Pod 进行路由。 "},{"id":17,"href":"/docs/%E7%9B%91%E6%8E%A7/","title":"监控","section":"文档首页","content":"欢迎使用prometheus\n"},{"id":18,"href":"/docs/%E7%AE%97%E6%B3%95/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/","title":"贪心算法","section":"算法","content":"本章节介绍贪心算法\n基本思想 # 局部最优解：在每一步决策中，选择当前状态下最优的局部解 无后效性：当前的选择不会影响后续的选择，即不依赖于未来的选择 希望导致全局最优解：通过一系列局部最优解，最终得到全局最优解 适用条件 # 贪心选择性质：问题的全局最优解可以通过一系列局部最优选择得到 最优子结构：问题的最优解包含子问题的最优解 步骤 # 问题分解：将问题分为若干个子问题 局部最优选择：对每个子问题，选择一个局部最优解 合并解：将局部最优解合并为全局解 经典应用 # 活动选择问题：选择最多的互不重叠的活动。 霍夫曼编码：构造最优前缀编码。 最小生成树：如Prim算法和Kruskal算法。 最短路径问题：如Dijkstra算法。 背包问题的分数版本：选择单位价值最高的物品。 优缺点 # 优点\n简单易实现 通常具有较高的效率 缺点 不总是能得到全局最优解 需要问题具有贪心选择性质和最优子结构 "},{"id":19,"href":"/docs/","title":"文档首页","section":"bei的个人博客","content":" 欢迎使用 Hugo Book 主题！ # "},{"id":20,"href":"/docs/kubernetes/operate/install/calico/","title":"calico","section":"install","content":"xxx\n"},{"id":21,"href":"/docs/kubernetes/develop/","title":"develop","section":"Kubernetes","content":"欢迎使用kubernetes\n"},{"id":22,"href":"/docs/kubernetes/","title":"Kubernetes","section":"文档首页","content":"欢迎使用kubernetes\n"},{"id":23,"href":"/docs/%E7%9B%91%E6%8E%A7/thanos/","title":"Thanos","section":"监控","content":"欢迎使用thanos\n"},{"id":24,"href":"/docs/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","title":"动态规划","section":"算法","content":"本章节介绍贪心算法\n基本原理 # 最优子结构 一个问题的最优解包含其子问题的最优解，换句话说，问题的最优解可以通过子问题的最优解推到出来 重叠子问题 在求解过程中，子问题会被多次重复计算，动态规划通过存储子问题的解（通常使用表格或数组），避免重复计算 适用条件 # 最优化问题： 背包问题（0-1 背包、完全背包） 最短路径问题（Floyd-Warshall 算法） 最长公共子序列（LCS） 最大子数组和 计数问题： 组合数问题 路径计数问题 序列问题： 斐波那契数列 编辑距离（Levenshtein 距离） 步骤 # 定义状态 明确问题的状态表示，通常一个或多个变量描述问题的子问题 确定状态转移方程 找到状态之间的关系，即如何从子问题的解推导出当前问题的解 初始化 确定初始状态的值，通常问题的最小规模情况 计算顺序 按照一定的顺序计算状态，通常是自底向上（从最小子问题开始）或自顶向下（递归 + 记忆化） 返回结果 根据状态或数组返回最终问题的解 优化 # 空间优化： 如果状态转移方程只依赖于前一个状态，可以使用滚动数组或变量来减少空间复杂度。 例如：斐波那契数列问题可以优化为只使用两个变量。 记忆化搜索： 自顶向下的递归方法，通过缓存子问题的解来避免重复计算。 "},{"id":25,"href":"/docs/kubernetes/operate/install/argo/","title":"argo","section":"install","content":"xxx\n"},{"id":26,"href":"/docs/%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF/","title":"回溯","section":"算法","content":"本章节介绍回溯方法\n基本思想 # 尝试构建解（探索） 如果不满足条件，则回退（回溯） 如果满足条件，则记录解 步骤 # 选择（Choose）：尝试做出选择，向解空间深处探索。 约束（Constraint）：检查当前选择是否满足问题约束条件，若不满足则回退。 撤销（Unchoose）：如果该选择导致后续无解，则撤销选择，回到上一步。 优缺点 # 优点\n易于实现：代码结构清晰，递归思维自然适配回溯法。 能求所有解：适用于组合、排列、子集问题，能遍历所有可能方案。 适用于树形结构问题：如决策树、DFS 搜索路径。 可以结合剪枝优化：如 used[] 记录状态、提前终止无效搜索。 缺点 时间复杂度高： 组合：O(C(n, k)) ≈ 指数级 排列：O(n!)（非常高） 迷宫：最坏 O(4^n)（四个方向尝试） 重复计算： 例如编辑距离计算，回溯会重复计算子问题，导致超时。 优化：记忆化搜索 + 剪枝。 不适合大规模数据： 搜索空间太大时，直接超时！ 需要优化，如 剪枝、DP 代替回溯。 "},{"id":27,"href":"/docs/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/first/","title":"跳跃游戏 2","section":"动态规划","content":" 跳跃游戏 2 # leetcode 45\nfunc jump(nums []int) int { n := len(nums) if n \u0026lt;= 1{ return 0 } steps , curEnd, maxReach := 0, 0, 0 for i :=0 ; i\u0026lt; n ; i ++{ maxReach = max(maxReach, i + nums[i]) if i == curEnd{ steps ++ curEnd = maxReach if curEnd \u0026gt;= n-1{ break } } } return steps } "},{"id":28,"href":"/docs/%E7%AE%97%E6%B3%95/%E5%8F%8C%E6%8C%87%E9%92%88/first/","title":"跳跃游戏 2","section":"双指针","content":" 跳跃游戏 2 # leetcode 45\nfunc jump(nums []int) int { n := len(nums) if n \u0026lt;= 1{ return 0 } steps , curEnd, maxReach := 0, 0, 0 for i :=0 ; i\u0026lt; n ; i ++{ maxReach = max(maxReach, i + nums[i]) if i == curEnd{ steps ++ curEnd = maxReach if curEnd \u0026gt;= n-1{ break } } } return steps } "},{"id":29,"href":"/docs/%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF/first/","title":"跳跃游戏 2","section":"回溯","content":" 跳跃游戏 2 # leetcode 45\nfunc jump(nums []int) int { n := len(nums) if n \u0026lt;= 1{ return 0 } steps , curEnd, maxReach := 0, 0, 0 for i :=0 ; i\u0026lt; n ; i ++{ maxReach = max(maxReach, i + nums[i]) if i == curEnd{ steps ++ curEnd = maxReach if curEnd \u0026gt;= n-1{ break } } } return steps } "},{"id":30,"href":"/docs/%E7%AE%97%E6%B3%95/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/first/","title":"跳跃游戏 2","section":"贪心算法","content":" 跳跃游戏 2 # leetcode 45\nfunc jump(nums []int) int { n := len(nums) if n \u0026lt;= 1{ return 0 } steps , curEnd, maxReach := 0, 0, 0 for i :=0 ; i\u0026lt; n ; i ++{ maxReach = max(maxReach, i + nums[i]) if i == curEnd{ steps ++ curEnd = maxReach if curEnd \u0026gt;= n-1{ break } } } return steps } "},{"id":31,"href":"/docs/%E7%AE%97%E6%B3%95/%E5%8F%8C%E6%8C%87%E9%92%88/","title":"双指针","section":"算法","content":"本章节介绍双指针\n基本思想 # 双指针（Two Pointers） 是一种常用的算法优化技巧，通过两个指针（索引）在数组或链表上进行遍历，减少不必要的重复计算，提高效率。 适用于 数组、字符串、链表等线性结构，\n查找 比较 去重 排序等。 适用条件 # 有序数组/字符串/链表，方便利用 左右对撞 或 快慢遍历。 寻找特定组合（如和为 target），可以通过 对撞指针 避免暴力解法。 需要动态维护窗口（如最长无重复子串），滑动窗口可高效解决问题。 步骤 # 问题分解：将问题分为若干个子问题 局部最优选择：对每个子问题，选择一个局部最优解 合并解：将局部最优解合并为全局解 经典应用 # 活动选择问题：选择最多的互不重叠的活动。 霍夫曼编码：构造最优前缀编码。 最小生成树：如Prim算法和Kruskal算法。 最短路径问题：如Dijkstra算法。 背包问题的分数版本：选择单位价值最高的物品。 优缺点 # 优点\n降低时间复杂度 套循环，降低 O(n²) 为 O(n)，减少不必要的计算。 适用于有序结构 有序数组、单调递增序列 可用双指针 高效查找目标值。 空间复杂度低 一般只需 O(1) 额外空间，避免额外数组或哈希表。 缺点\n不适用于无序数组 例如 无序数组求和 不能直接用 对撞指针。 有些问题无法规避嵌套循环 例如 四数之和 仍然需要 O(n³)。 复杂情况需要额外逻辑 滑动窗口有时候需要 哈希表 记录状态。 "},{"id":32,"href":"/docs/%E7%AE%97%E6%B3%95/%E5%A0%86/","title":"堆","section":"算法","content":"本章节介绍堆\n基本思想 # 堆通常用完全二叉树实现，并存储在数组中，保证高效的插入和删除操作 最大堆：每个节点的值都大于等于其子节点的值，根节点是最大值 最小堆：每个节点的值都小于其子节点的值，根节点是最小值 存储方式 # 使用数组表示完全二叉树 操作 # 插入操作\n把新元素插入到数组末尾 上浮 删除堆顶元素\n用最后一个元素替换堆顶 下沉 堆排序\n构建最大堆 交换根节点和最后一个元素 调整堆 重复上述步骤，直到排序完成 经典应用 # 优先队列（Priority Queue） 使用最小堆实现任务优先级调度 使用最大堆实现Top K 问题 求TOP K 大/小元素 最小堆求TOP K 大元素 最大堆求TOP K 小元素 中位数维护 左边最大堆（维护较小的一半数） 右边最小堆（维护较大的一半数） 中位数为两堆的顶元素 优缺点 # 优点\n插入、删除 操作时间复杂度 O(log n) 动态维护 Top K 问题，适用于大数据场景 优先队列实现简单高效 缺点\n不支持快速查找（不像哈希表 O(1)） 堆排序不是稳定排序（相同元素相对顺序可能改变） 数组实现堆可能需要额外的空间移动 示例 # 最小堆\nimport \u0026#34;container/heap\u0026#34; type MinHeap []int func (h MinHeap) Len() int { return len(h) } func (h MinHeap) Less(i, j int) bool { return h[i] \u0026lt; h[j] } // 最小堆 func (h MinHeap) Swap(i, j int) { h[i], h[j] = h[j], h[i] } func (h *MinHeap) Push(x any) { *h = append(*h, x.(int)) } func (h *MinHeap) Pop() any { old := *h n := len(old) x := old[n-1] *h = old[:n-1] return x } func main() { h := \u0026amp;MinHeap{} heap.Init(h) heap.Push(h, 5) heap.Push(h, 2) heap.Push(h, 8) heap.Push(h, 1) fmt.Println(heap.Pop(h)) // 1 } "}]