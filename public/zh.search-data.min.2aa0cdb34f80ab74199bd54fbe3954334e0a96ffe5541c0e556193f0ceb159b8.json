[{"id":0,"href":"/docs/%E4%BA%91%E5%8E%9F%E7%94%9F/%E7%9B%91%E6%8E%A7/metrics/prometheus/questions/01/","title":"01","section":"questions","content":" 如何在kubernetes中如何抓取服务的metrics # prometheus 中自带的几个metrics # prometheus 如何将数据发送给远端存储 # 介绍一下prometheus WAL 机制 # prometheus 使用什么压缩算法压缩数据 # "},{"id":1,"href":"/docs/%E4%BA%91%E5%8E%9F%E7%94%9F/%E7%9B%91%E6%8E%A7/metrics/prometheus/develop/","title":"develop","section":"prometheus","content":" prometheus 源码解读 # "},{"id":2,"href":"/docs/go/first/","title":"First","section":"Go","content":" Golang的基本介绍 # "},{"id":3,"href":"/docs/go/","title":"Go","section":"文档首页","content":"本章节介绍 Hugo 的基本使用。\n"},{"id":4,"href":"/docs/%E4%BA%91%E5%8E%9F%E7%94%9F/kubernetes/develop/client-go/informer/","title":"informer","section":"client-go","content":" "},{"id":5,"href":"/docs/%E4%BA%91%E5%8E%9F%E7%94%9F/kubernetes/operate/install/","title":"install","section":"operate","content":"欢迎使用kubernetes\n"},{"id":6,"href":"/docs/%E4%BA%91%E5%8E%9F%E7%94%9F/%E7%9B%91%E6%8E%A7/metrics/prometheus/operator/install/","title":"install","section":"operator","content":" prometheus 源码解读 # "},{"id":7,"href":"/docs/%E4%BA%91%E5%8E%9F%E7%94%9F/kubernetes/operate/install/kubernetes/","title":"kubernetes","section":"install","content":" 部署前准备 # 修改机器名 hostnamectl set-hostname master 关闭swap swapoff -a sed -i \u0026#39;/swap / s/^\\(.*\\)$/#\\1/g\u0026#39; /etc/fstab free -m # 检查是否关闭swap ssh允许Root 登陆 vim /etc/ssh/sshd_config 增加 Port 22 PermitRootLogin yes passwd # 设置root 密码 关闭防火墙 sudo ufw disable 修改apt 源地址 cp /etc/apt/sources.list /etc/apt/sources.list.bak # 使用vim 替换/etc/apt/sources.list中的资源地址 vim /etc/apt/sources.list deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse # 更新 vim /etc/resolv.conf # 添加一下两行 nameserver 8.8.8.8 nameserver 8.8.4.4 apt-get update 添加 Kubernetes apt 存储库 sudo tee /etc/apt/sources.list.d/kubernetes.list \u0026lt;\u0026lt;-\u0026#39;EOF\u0026#39; deb https://mirrors.aliyun.com/kubernetes/apt kubernetes-xenial main EOF apt-get update The following signatures couldn\u0026#39;t be verified because the public key is not available: NO_PUBKEY B53DC80D13EDEF05 NO_PUBKEY FEEA9169307EA071 # 如果报错以上错误，执行下面一条命令 recv-keys 是报错现实的NO_PUBKEY sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys FEEA9169307EA071 安装kubectl kubeadm kubelet sudo apt-get install -y kubelet=1.22.2-00 kubeadm=1.22.2-00 kubectl=1.22.2-00 安装docker apt-get install -y docker.io systemctl enable docker master # 安装master 节点 kubeadm init \\ --apiserver-advertise-address=192.168.31.239 \\ --image-repository registry.aliyuncs.com/google_containers \\ --kubernetes-version v1.22.0 \\ --service-cidr=10.96.0.0/12 \\ --pod-network-cidr=10.244.0.0/16 node # 安装node 节点 kubeadm join 192.168.31.208:6443 --token u1soc8.1xyeqbzptpvvjz8f --discovery-token-ca-cert-hash sha256:3406b992b2c05f27b398a81375082a72aa2a823fd82616e4f8cb6f2a24370bb3 # kubeadm init 初始化完成会打印到console 上 # 可以通过 kubeadm token create --print-join-command 查看 "},{"id":8,"href":"/docs/%E4%BA%91%E5%8E%9F%E7%94%9F/kubernetes/","title":"Kubernetes","section":"云原生","content":"kubernetes 架构图\nGroup、Version、Resource 核心数据结构 # 整个Kubernetes 体系架构中，资源是Kubernetes最重要的概念，可以说Kubernets的生态系统都围绕着资源运作。\nKubernetes系统虽然有相当复杂和众多的功能，但是它本质上是一个资源控制系统——注册、管理、调度资源并维护资源的状态\nKubernetes 将资源分组和版本化，形成Group（资源组）、Version（资源版本）、Resource（资源）\nGroup：资源组，在Kubernetes API Server 中也可称其为APIGroup Version：资源版本，在Kubernets API Server 中也可称其为APIVersions Resource：资源，在Kubernetes API Server 中也可称其为APIResource Kind：资源种类，描述Resource 的种类，与Resource为同一级别 Kubernetes 系统支持多个Group。每个Group支持多个Version，每个Version支持多个Resource，同时部分资源会拥有自己的子资源\n资源组、资源版本、资源、子资源的完整表达形式为\u0026lt;group\u0026gt;/\u0026lt;version\u0026gt;/\u0026lt;resource\u0026gt;/\u0026lt;status\u0026gt;,以常用的Deployment资源为例，其完整表现形式为apps/v1/deployments/status\n资源对象由 资源组 + 资源版本 + 资源种类组成，例如Deployment 资源是实例化后拥有资源组、资源版本及资源种类，其表现形式为/,Kind=,例如apps/v1，Kind= Deployment\n每一个资源都拥有一定数量的资源操作方法（即Verbs），资源操作方法用于Etcd集群存储中对资源对象的增、删、改、查操作。目前Kubernetes系统支持8种资源操作方法，分别是create、delete、deletecollection、get、list、patch、update、watch操作方法\n"},{"id":9,"href":"/docs/%E4%BA%91%E5%8E%9F%E7%94%9F/%E7%9B%91%E6%8E%A7/metrics/prometheus/operator/install/kubernetes-services/","title":"kubernetes service","section":"install","content":"scrape_configs: - job_name: \u0026#39;kubernetes-pods\u0026#39; kubernetes_sd_configs: - role: pod relabel_configs: # 提取 annotation 中的 metrics_path - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_path] action: replace target_label: __metrics_path__ # 提取 annotation 中的 scrape interval - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_scrape_interval] action: replace target_label: scrape_interval # 提取 annotation 中的 scrape timeout - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_scrape_timeout] action: replace target_label: scrape_timeout # 通过 annotation 设置是否启用 scrape - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_scrape] action: keep regex: \u0026#34;true\u0026#34; # 提取 annotation 中的 metrics 端口 - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_port] action: replace target_label: __address__ regex: (.+) replacement: $1 apiVersion: v1 kind: Pod metadata: name: example-app annotations: prometheus.io/scrape: \u0026#34;true\u0026#34; prometheus.io/path: \u0026#34;/metrics\u0026#34; prometheus.io/port: \u0026#34;8080\u0026#34; prometheus.io/scrape_interval: \u0026#34;15s\u0026#34; prometheus.io/scrape_timeout: \u0026#34;10s\u0026#34; spec: containers: - name: example image: example-app ports: - containerPort: 8080 "},{"id":10,"href":"/docs/%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF/1.-n-%E7%9A%87%E5%90%8E/","title":"N 皇后","section":"回溯","content":" N 皇后 # leetcode 51\n按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。\nn 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。\n给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。\n每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 \u0026lsquo;Q\u0026rsquo; 和 \u0026lsquo;.\u0026rsquo; 分别代表了皇后和空位。\n示例 1： 输入：n = 4\n输出：[[\u0026quot;.Q..\u0026quot;,\u0026quot;\u0026hellip;Q\u0026quot;,\u0026ldquo;Q\u0026hellip;\u0026rdquo;,\u0026quot;..Q.\u0026quot;],[\u0026quot;..Q.\u0026quot;,\u0026ldquo;Q\u0026hellip;\u0026rdquo;,\u0026quot;\u0026hellip;Q\u0026quot;,\u0026quot;.Q..\u0026quot;]]\n解释：如上图所示，4 皇后问题存在两个不同的解法。\n示例 2：\n输入：n = 1\n输出：[[\u0026ldquo;Q\u0026rdquo;]]\nfunc solveNQueens(n int) [][]string { var result [][]string board := make([][]rune, n) for i := range board{ board[i] = make([]rune, n) for j := range board[i]{ board[i][j] = \u0026#39;.\u0026#39; } } var dfs func(row int, cols, diag1, diag2 map[int]bool) dfs = func(row int, cols, diag1, diag2 map[int]bool){ if row == n{ var solution []string for _, r := range board{ solution = append(solution, string(r)) } result = append(result, solution) return } for col := 0; col \u0026lt; n; col ++{ if cols[col] || diag1[row-col] || diag2[row+col]{ continue } board[row][col] = \u0026#39;Q\u0026#39; cols[col], diag1[row-col], diag2[col + row] = true, true, true dfs(row + 1, cols, diag1, diag2) board[row][col] = \u0026#39;.\u0026#39; delete(cols, col) delete(diag1, row -col) delete(diag2, row + col) } } dfs(0, make(map[int]bool), make(map[int]bool), make(map[int]bool)) return result } "},{"id":11,"href":"/docs/%E4%BA%91%E5%8E%9F%E7%94%9F/%E7%9B%91%E6%8E%A7/metrics/prometheus/operator/","title":"operator","section":"prometheus","content":" prometheus 源码解读 # "},{"id":12,"href":"/docs/%E4%BA%91%E5%8E%9F%E7%94%9F/%E7%9B%91%E6%8E%A7/metrics/prometheus/","title":"prometheus","section":"metrics","content":"prometheus 架构图\n"},{"id":13,"href":"/docs/%E4%BA%91%E5%8E%9F%E7%94%9F/%E7%9B%91%E6%8E%A7/metrics/prometheus/operator/install/prometheus/","title":"prometheus","section":"install","content":" prometheus 的安装 # 使用 kube-prometheus 安装\n组件 # prometheus-adpter prometheus-operator alertmanager blackbox-exporter grafana prometheus kube-state-metrics node-exporter kubernetetsControllerPlan "},{"id":14,"href":"/docs/%E4%BA%91%E5%8E%9F%E7%94%9F/%E7%9B%91%E6%8E%A7/metrics/prometheus/develop/source-code/","title":"prometheus source code","section":"develop","content":" 模块列表 # discoveryManagerScrape 服务发现 scrapeManager queryEngine ruleManager discoveryManagerNotify notifierManager tracingManager "},{"id":15,"href":"/docs/%E4%BA%91%E5%8E%9F%E7%94%9F/kubernetes/develop/reources/","title":"resources","section":"develop","content":" Group、Version、Resource 核心数据结构 # 整个Kubernetes 体系架构中，资源是Kubernetes最重要的概念，可以说Kubernets的生态系统都围绕着资源运作。\nKubernetes系统虽然有相当复杂和众多的功能，但是它本质上是一个资源控制系统——注册、管理、调度资源并维护资源的状态\nKubernetes 将资源分组和版本化，形成Group（资源组）、Version（资源版本）、Resource（资源）\nGroup：资源组，在Kubernetes API Server 中也可称其为APIGroup Version：资源版本，在Kubernets API Server 中也可称其为APIVersions Resource：资源，在Kubernetes API Server 中也可称其为APIResource Kind：资源种类，描述Resource 的种类，与Resource为同一级别 Kubernetes 系统支持多个Group。每个Group支持多个Version，每个Version支持多个Resource，同时部分资源会拥有自己的子资源\n资源组、资源版本、资源、子资源的完整表达形式为\u0026lt;group\u0026gt;/\u0026lt;version\u0026gt;/\u0026lt;resource\u0026gt;/\u0026lt;status\u0026gt;,以常用的Deployment资源为例，其完整表现形式为apps/v1/deployments/status\n资源对象由 资源组 + 资源版本 + 资源种类组成，例如Deployment 资源是实例化后拥有资源组、资源版本及资源种类，其表现形式为/,Kind=,例如apps/v1，Kind= Deployment\n每一个资源都拥有一定数量的资源操作方法（即Verbs），资源操作方法用于Etcd集群存储中对资源对象的增、删、改、查操作。目前Kubernetes系统支持8种资源操作方法，分别是create、delete、deletecollection、get、list、patch、update、watch操作方法\nKubernetes的资源也分两种，分别是Kubernetes Resource（kubernetes 内置资源） 和 Custom Resource（自定义资源）。开发者通过CRD（即Custom Resource Definitions）可实现自定义资源，它允许用户将自己定义的资源添加到Kubenetes 系统中，并像使用kubernetes 内置资源一样使用它们\n"},{"id":16,"href":"/docs/linux/%E7%BD%91%E7%BB%9C/tcp%E5%8D%8F%E8%AE%AE/","title":"tcp 协议","section":"网络","content":" 详解三次握手，四次挥手 # 三次握手（建立连接） # TCP采用 三次握手（Three-Way Handshake） 过程来建立可靠连接：\n客户端发送 SYN（同步序列号）： 客户端向服务器发送一个 SYN 报文，表示请求建立连接。 该报文的 SYN=1，并包含一个初始序列号 seq=x。 服务器回应 SYN-ACK： 服务器收到 SYN 后，发送 SYN=1, ACK=1，并附带自己的初始序列号 seq=y，确认客户端的 seq=x+1。 客户端回应 ACK： 客户端收到服务器的 SYN-ACK 后，发送 ACK=1，确认 seq=y+1，同时携带 seq=x+1。 四次挥手（断开连接） # TCP 采用 四次挥手（Four-Way Handshake） 断开连接：\n客户端发送 FIN： 客户端想要断开连接，发送 FIN=1，表示无数据可发。 服务器发送 ACK： 服务器收到 FIN 后，回复 ACK=1，但可能仍有未发送的数据。 服务器发送 FIN： 服务器确认数据发送完毕，发送 FIN=1 断开连接。 客户端发送 ACK，完成断开： 客户端确认 FIN，回复 ACK=1，连接正式关闭。 "},{"id":17,"href":"/docs/%E4%BA%91%E5%8E%9F%E7%94%9F/kubernetes/questions/%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%97%A0%E7%8A%B6%E6%80%81%E6%9C%8D%E5%8A%A1kubernetes%E7%9A%84%E5%86%85%E9%83%A8%E6%B5%81%E7%A8%8B/","title":"创建一个无状态服务","section":"questions","content":" 创建一个deployment资源 # 当创建一个deployment时，kubernetes 内部是如何处理的？\n创建 Deployment 资源 用户通过 kubectl apply 或 API 直接创建一个 Deployment 资源。 kube-apiserver 接收到请求后，将 Deployment 对象写入 etcd 数据库。 controller-manager 处理 Deployment kube-controller-manager 监听 Deployment 资源（通过 watch 机制）。 发现新建的 Deployment，DeploymentController 计算出需要创建的 ReplicaSet（如果是更新，还会进行滚动升级）。 controller-manager 通过 kube-apiserver 创建 ReplicaSet 资源。 controller-manager 处理 ReplicaSet kube-controller-manager 监听 ReplicaSet 资源（通过 watch 机制）。 发现新建的 ReplicaSet，ReplicaSetController 计算出需要创建的 Pod。 controller-manager 通过 kube-apiserver 创建 Pod 资源。 kube-scheduler 进行调度 kube-scheduler 监听 Pod 资源的变更（通过 watch 机制）。 发现 Pod 处于 Pending 状态，调度器计算出合适的 Node（根据 CPU、内存、调度策略等）。 kube-scheduler 通过 kube-apiserver 更新 Pod 的 spec.nodeName，分配到合适的节点。 kubelet 负责拉起容器 kubelet 监听 kube-apiserver，发现被分配到自己节点的 Pod。 kubelet 通过 Container Runtime Interface (CRI) 执行： 创建网络（调用 CNI 插件，分配 IP）。 挂载存储（调用 CSI 插件，挂载 Volume）。 启动容器（调用 CRI，使用 containerd 或 Docker 等创建容器）。 kubelet 通过 kube-apiserver 更新 Pod 状态（Running）。 创建一个service资源 # kube-proxy 监听 kube-apiserver 上的 service 资源的创建： 当 kube-proxy 监视到新的服务资源（Service）时，它会根据 Service 中的标签（labels）来筛选出符合条件的 Pod。这些 Pod 是与该 Service 相关联的目标（后端）。通过这些信息，kube-proxy 创建一个 Endpoints 资源对象，指向这些 Pod。 kube-proxy 监听 endpoint 资源的变化： Endpoints 资源对象被创建或更新，kube-proxy 就会动态地根据新的 Endpoint 信息来修改其网络规则（如 iptables 或 ipvs）。 kube-proxy 根据 Endpoint 中的 Pod 地址创建或更新相应的 iptables 或 ipvs 规则，这样流量就可以通过正确的后端 Pod 进行路由。 "},{"id":18,"href":"/docs/%E7%AE%97%E6%B3%95/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/1.-%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%90/","title":"腐烂的橘子","section":"拓扑排序","content":" 腐烂的橘子 # leetcode 994\n在给定的 m x n 网格 grid 中，每个单元格可以有以下三个值之一：\n值 0 代表空单元格； 值 1 代表新鲜橘子； 值 2 代表腐烂的橘子。 每分钟，腐烂的橘子 周围 4 个方向上相邻 的新鲜橘子都会腐烂。\n返回 直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1 。\n示例 1：\n输入：grid = [[2,1,1],[1,1,0],[0,1,1]]\n输出：4\n示例 2：\n输入：grid = [[2,1,1],[0,1,1],[1,0,1]]\n输出：-1\n解释：左下角的橘子（第 2 行， 第 0 列）永远不会腐烂，因为腐烂只会发生在 4 个方向上。\n示例 3：\n输入：grid = [[0,2]]\n输出：0\n解释：因为 0 分钟时已经没有新鲜橘子了，所以答案就是 0 。\ntype Point struct { x, y, time int } func orangesRotting(grid [][]int) int { rows, cols := len(grid), len(grid[0]) freshCount := 0 queue := []*Point{} directions := [][]int{{1,0}, {-1, 0}, {0, 1}, {0, -1}} totalTime := 0 for i:=0; i \u0026lt; (rows); i++{ for j := 0; j \u0026lt; (cols); j++{ if grid[i][j] == 2{ queue = append(queue, \u0026amp;Point{i, j, 0}) }else if grid[i][j] == 1{ freshCount ++ } } } for len(queue) != 0{ p := queue[0] queue = queue[1:] for _, direction := range directions { newX, newY := p.x + direction[0], p.y + direction[1] if newX \u0026gt;= 0 \u0026amp;\u0026amp; newX \u0026lt; rows \u0026amp;\u0026amp; newY \u0026gt;= 0 \u0026amp;\u0026amp; newY \u0026lt; cols \u0026amp;\u0026amp; grid[newX][newY] == 1{ grid[newX][newY] = 2 queue = append(queue, \u0026amp;Point{newX, newY, p.time + 1}) freshCount -- totalTime = p.time + 1 } } } if freshCount != 0{ return -1 } return totalTime } "},{"id":19,"href":"/docs/%E7%AE%97%E6%B3%95/%E5%8F%8C%E6%8C%87%E9%92%88/1.%E6%8E%A5%E9%9B%A8%E6%B0%B4/","title":"接雨水","section":"双指针","content":" 接雨水 # leetcode 45\n给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。\n示例 1：\n输入：height = [0,1,0,2,1,0,1,3,2,1,2,1] 输出：6 解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 示例 2：\n输入：height = [4,2,0,3,2,5] 输出：9\nfunc trap(height []int) int { left, right := 0, len(height) -1 leftMax, rightMax := 0, 0 totalWater := 0 for left \u0026lt; right{ if height[left] \u0026lt; height[right]{ if height[left] \u0026lt; leftMax{ totalWater += leftMax - height[left] }else{ leftMax = height[left] } left ++ } else{ if height[right] \u0026gt;= rightMax{ rightMax = height[right] }else{ totalWater += rightMax - height[right] } right-- } } fmt.Println(left, right) return totalWater } "},{"id":20,"href":"/docs/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/1.-%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/","title":"前序遍历","section":"二叉树","content":" 前序遍历 # 根 → 左子树 → 右子树\nfunc preOrderTraversal(root *TreeNode) []int { if root == nil { return []int{} } stack, res := []*TreeNode{root}, []int{} for len(stack) \u0026gt; 0 { node := stack[len(stack)-1] stack = stack[:len(stack)-1] res = append(res, node.Val) if node.Right != nil { stack = append(stack, node.Right) } if node.Left != nil { stack = append(stack, node.Left) } } return res } "},{"id":21,"href":"/docs/%E7%AE%97%E6%B3%95/%E5%A0%86/1.-%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/","title":"数据流的中位数","section":"堆","content":" 数据流的中位数 # leetcode 295\n中位数是有序整数列表中的中间值。如果列表的大小是偶数，则没有中间值，中位数是两个中间值的平均值。\n例如 arr = [2,3,4] 的中位数是 3 。\n例如 arr = [2,3] 的中位数是 (2 + 3) / 2 = 2.5 。\n实现 MedianFinder 类:\nMedianFinder() 初始化 MedianFinder 对象。\nvoid addNum(int num) 将数据流中的整数 num 添加到数据结构中。\ndouble findMedian() 返回到目前为止所有元素的中位数。与实际答案相差 10-5 以内的答案将被接受。\n示例 1：\n输入 [\u0026ldquo;MedianFinder\u0026rdquo;, \u0026ldquo;addNum\u0026rdquo;, \u0026ldquo;addNum\u0026rdquo;, \u0026ldquo;findMedian\u0026rdquo;, \u0026ldquo;addNum\u0026rdquo;, \u0026ldquo;findMedian\u0026rdquo;]\n[[], [1], [2], [], [3], []] 输出 [null, null, null, 1.5, null, 2.0]\n解释 MedianFinder medianFinder = new MedianFinder();\nmedianFinder.addNum(1); // arr = [1]\nmedianFinder.addNum(2); // arr = [1, 2]\nmedianFinder.findMedian(); // 返回 1.5 ((1 + 2) / 2)\nmedianFinder.addNum(3); // arr[1, 2, 3]\nmedianFinder.findMedian(); // return 2.0\ntype MaxHeap struct{ nums []int } func (h MaxHeap) Len() int { return len(h.nums) } func (h MaxHeap) Less(i, j int) bool { return h.nums[i] \u0026gt; h.nums[j] } // 大根堆 func (h MaxHeap) Swap(i, j int) { h.nums[i], h.nums[j] = h.nums[j], h.nums[i] } func (h *MaxHeap) Push(x interface{}) { h.nums = append(h.nums, x.(int)) } func (h *MaxHeap) Pop() interface{} { old := h.nums n := len(old) x := old[n-1] h.nums = old[:n-1] return x } // 小根堆（存较大的一半数据） type MinHeap struct{ nums []int } func (h MinHeap) Len() int { return len(h.nums) } func (h MinHeap) Less(i, j int) bool { return h.nums[i] \u0026lt; h.nums[j] } // 小根堆 func (h MinHeap) Swap(i, j int) { h.nums[i], h.nums[j] = h.nums[j], h.nums[i] } func (h *MinHeap) Push(x interface{}) { h.nums = append(h.nums, x.(int)) } func (h *MinHeap) Pop() interface{} { old := h.nums n := len(old) x := old[n-1] h.nums = old[:n-1] return x } // 数据流中位数 type MedianFinder struct { maxHeap *MaxHeap // 大根堆 minHeap *MinHeap // 小根堆 } // 初始化 func Constructor() MedianFinder { return MedianFinder{ maxHeap: \u0026amp;MaxHeap{}, minHeap: \u0026amp;MinHeap{}, } } // 添加数字 func (mf *MedianFinder) AddNum(num int) { heap.Push(mf.maxHeap, num) // 先放入大根堆 heap.Push(mf.minHeap, heap.Pop(mf.maxHeap)) // 平衡到小根堆 // 如果小根堆元素多于大根堆，则调整 if mf.minHeap.Len() \u0026gt; mf.maxHeap.Len() { heap.Push(mf.maxHeap, heap.Pop(mf.minHeap)) } } // 获取中位数 func (mf *MedianFinder) FindMedian() float64 { if mf.maxHeap.Len() \u0026gt; mf.minHeap.Len() { return float64(mf.maxHeap.nums[0]) } return float64(mf.maxHeap.nums[0]+mf.minHeap.nums[0]) / 2.0 } "},{"id":22,"href":"/docs/%E7%AE%97%E6%B3%95/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/","title":"贪心算法","section":"算法","content":"本章节介绍贪心算法\n基本思想 # 局部最优解：在每一步决策中，选择当前状态下最优的局部解 无后效性：当前的选择不会影响后续的选择，即不依赖于未来的选择 希望导致全局最优解：通过一系列局部最优解，最终得到全局最优解 适用条件 # 贪心选择性质：问题的全局最优解可以通过一系列局部最优选择得到 最优子结构：问题的最优解包含子问题的最优解 步骤 # 问题分解：将问题分为若干个子问题 局部最优选择：对每个子问题，选择一个局部最优解 合并解：将局部最优解合并为全局解 经典应用 # 活动选择问题：选择最多的互不重叠的活动。 霍夫曼编码：构造最优前缀编码。 最小生成树：如Prim算法和Kruskal算法。 最短路径问题：如Dijkstra算法。 背包问题的分数版本：选择单位价值最高的物品。 优缺点 # 优点\n简单易实现 通常具有较高的效率 缺点 不总是能得到全局最优解 需要问题具有贪心选择性质和最优子结构 "},{"id":23,"href":"/docs/%E7%AE%97%E6%B3%95/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/first/","title":"跳跃游戏 2","section":"贪心算法","content":" 跳跃游戏 2 # leetcode 45\n给定一个长度为 n 的 0 索引整数数组 nums。初始位置为 nums[0]。\n每个元素 nums[i] 表示从索引 i 向后跳转的最大长度。换句话说，如果你在 nums[i] 处，你可以跳转到任意 nums[i + j] 处:\n0 \u0026lt;= j \u0026lt;= nums[i] i + j \u0026lt; n 返回到达 nums[n - 1] 的最小跳跃次数。生成的测试用例可以到达 nums[n - 1]。\n示例 1:\n输入: nums = [2,3,1,1,4] 输出: 2 解释: 跳到最后一个位置的最小跳跃数是 2。 从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。 示例 2:\n输入: nums = [2,3,0,1,4] 输出: 2\nfunc jump(nums []int) int { n := len(nums) if n \u0026lt;= 1{ return 0 } steps , curEnd, maxReach := 0, 0, 0 for i :=0 ; i\u0026lt; n ; i ++{ maxReach = max(maxReach, i + nums[i]) if i == curEnd{ steps ++ curEnd = maxReach if curEnd \u0026gt;= n-1{ break } } } return steps } "},{"id":24,"href":"/docs/%E4%BA%91%E5%8E%9F%E7%94%9F/kubernetes/questions/%E7%BD%91%E7%BB%9C/","title":"网络","section":"questions","content":" kubernetes 容器提供一个服务，外部访问慢，如何排查是容器网络原因还是服务本身的问题 # 如果容器内部没有sh 和网络工具，如何查看pod 内部的网络连接 # 使用 kubectl debug kubernetes 提供了kubectl debug让你可以在pod的网络namespace 内运行一个临时容器，该容器可以包含网络工具，如netstat、ss、curl、tcpdump等\nkubectl debug -it \u0026lt;pod-name\u0026gt; --image=busybox --target=\u0026lt;container-name\u0026gt; 使用nsenter 进入pod的网络Namespace 如果你有集群节点的权限，可以找到pod运行的节点，并使用nsenter 进入pod的网络的namespace # 先找到 Pod 运行在哪个节点 kubectl get pod \u0026lt;pod-name\u0026gt; -o wide # SSH 进入该节点，然后找到 Pod 对应的容器 ID docker ps | grep \u0026lt;pod-name\u0026gt; # 如果是 Docker 运行时 crictl ps | grep \u0026lt;pod-name\u0026gt; # 如果是 containerd 或 CRI-O 运行时 # 获取网络 namespace，并使用 nsenter 进入 PID=$(docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; \u0026lt;container-id\u0026gt;) # Docker PID=$(crictl inspect --output go-template --template \u0026#39;{{.info.pid}}\u0026#39; \u0026lt;container-id\u0026gt;) # containerd nsenter -t $PID -n netstat -an nsenter -t $PID -n ss -tnlp 使用tcpdump在Node 上抓包 tcpdump -i any port \u0026lt;pod-port\u0026gt; kubectl get pod \u0026lt;pod-name\u0026gt; -o jsonpath=\u0026#39;{.status.podIP}\u0026#39; tcpdump -i any host \u0026lt;pod-IP\u0026gt; "},{"id":25,"href":"/docs/","title":"文档首页","section":"bei的个人博客","content":" 欢迎使用 Hugo Book 主题！ # "},{"id":26,"href":"/docs/%E7%AE%97%E6%B3%95/%E5%88%86%E6%B2%BB%E6%B3%95/1.-%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/","title":"寻找旋转排序数组中的最小值","section":"分治法","content":" 寻找旋转排序数组中的最小值 # leetcode 153\n已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到：\n若旋转 4 次，则可以得到 [4,5,6,7,0,1,2]\n若旋转 7 次，则可以得到 [0,1,2,4,5,6,7]\n注意，数组 [a[0], a[1], a[2], \u0026hellip;, a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], \u0026hellip;, a[n-2]] 。\n给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。\n你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。\n示例 1：\n输入：nums = [3,4,5,1,2]\n输出：1\n解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。\n示例 2：\n输入：nums = [4,5,6,7,0,1,2]\n输出：0\n解释：原数组为 [0,1,2,4,5,6,7] ，旋转 4 次得到输入数组。\n示例 3：\n输入：nums = [11,13,15,17]\n输出：11\n解释：原数组为 [11,13,15,17] ，旋转 4 次得到输入数组。\nfunc findMin(nums []int) int { left, right := 0, len(nums) -1 for left \u0026lt; right{ mid := (left + right) / 2 if nums[mid] \u0026gt; nums[right]{ left = mid + 1 }else{ right = mid } } return nums[left] } "},{"id":27,"href":"/docs/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1.-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/","title":"最长公共子序列","section":"动态规划","content":" 最长公共子序列 # leetcode 300\n给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。\n一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。\n例如，\u0026ldquo;ace\u0026rdquo; 是 \u0026ldquo;abcde\u0026rdquo; 的子序列，但 \u0026ldquo;aec\u0026rdquo; 不是 \u0026ldquo;abcde\u0026rdquo; 的子序列。 两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。\nfunc longestCommonSubsequence(text1 string, text2 string) int { m, n := len(text1), len(text2) dp := make([][]int, m+1) for i := range dp { dp[i] = make([]int, n+1) } for i := 1; i \u0026lt;= m; i++ { for j := 1; j \u0026lt;= n; j++ { if text1[i-1] == text2[j-1] { dp[i][j] = dp[i-1][j-1] + 1 } else { dp[i][j] = max(dp[i-1][j], dp[i][j-1]) } } } return dp[m][n] } "},{"id":28,"href":"/docs/%E4%BA%91%E5%8E%9F%E7%94%9F/kubernetes/operate/install/calico/","title":"calico","section":"install","content":"xxx\n"},{"id":29,"href":"/docs/%E4%BA%91%E5%8E%9F%E7%94%9F/kubernetes/develop/client-go/","title":"client-go","section":"develop","content":"欢迎使用client-go\n"},{"id":30,"href":"/docs/%E4%BA%91%E5%8E%9F%E7%94%9F/kubernetes/develop/controller-runtime/","title":"controller runtime","section":"develop","content":"欢迎使用controller runtime\n"},{"id":31,"href":"/docs/%E4%BA%91%E5%8E%9F%E7%94%9F/kubernetes/develop/","title":"develop","section":"Kubernetes","content":"欢迎使用kubernetes\n"},{"id":32,"href":"/docs/%E4%BA%91%E5%8E%9F%E7%94%9F/kubernetes/develop/client-go/example/","title":"example","section":"client-go","content":" example code\n创建CRD 结构 /pkg/apis/example/v1/types.go\ntype MyResource struct { metav1.TypeMeta `json:\u0026#34;,inline\u0026#34;` metav1.ObjectMeta `json:\u0026#34;metadata,omitempty\u0026#34;` Spec MyResourceSpec `json:\u0026#34;spec\u0026#34;` } // MyResourceSpec defines the desired state of MyResource type MyResourceSpec struct { Foo string `json:\u0026#34;foo\u0026#34;` Bar int `json:\u0026#34;bar\u0026#34;` } 使用code-generator 工具自动生成clientSet、informer、lister bash hack/update-codegen.sh 定义controller 结构 /pkg/controller/contronller.go\ntype Controller struct { kubeclientset kubernetes.Interface myresourceClientset clientset.Interface myresourceLister listers.MyResourceLister myresourceSynced cache.InformerSynced workqueue workqueue.TypedRateLimitingInterface[string] } 初始化controller /pkg/controller/contronller.go\nfunc NewController( kubeclientset kubernetes.Interface, myresourceClientset clientset.Interface, myresourceInformer v1.MyResourceInformer) *Controller { controller := \u0026amp;Controller{ kubeclientset: kubeclientset, myresourceClientset: myresourceClientset, myresourceLister: myresourceInformer.Lister(), myresourceSynced: myresourceInformer.Informer().HasSynced, workqueue: workqueue.NewTypedRateLimitingQueueWithConfig( workqueue.DefaultTypedControllerRateLimiter[string](), workqueue.TypedRateLimitingQueueConfig[string]{ Name: \u0026#34;my-controller\u0026#34;, }, ), } myresourceInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs{ AddFunc: controller.enqueueMyResource, UpdateFunc: func(old, new interface{}) { controller.enqueueMyResource(new) }, DeleteFunc: controller.enqueueMyResource, }) return controller } set up /metrics and /healthz接口 /pkg/controller/contronller.go\n// Set up metrics server http.Handle(\u0026#34;/metrics\u0026#34;, promhttp.Handler()) go func() { klog.Fatal(http.ListenAndServe(\u0026#34;:8080\u0026#34;, nil)) }() // Set up health check server http.HandleFunc(\u0026#34;/healthz\u0026#34;, health.HealthCheck) go func() { klog.Fatal(http.ListenAndServe(\u0026#34;:8081\u0026#34;, nil)) }() 使用leaderelection 编写高可用controller /cmd/my-controller.go\nlock := \u0026amp;resourcelock.LeaseLock{ LeaseMeta: metav1.ObjectMeta{ Name: leaseLockName, Namespace: leaseLockNamespace, }, Client: kubeClient.CoordinationV1(), LockConfig: resourcelock.ResourceLockConfig{ Identity: os.Getenv(\u0026#34;POD_NAME\u0026#34;), // Use the pod name as the identity }, } leaderelection.RunOrDie(context.TODO(), leaderelection.LeaderElectionConfig{ Lock: lock, ReleaseOnCancel: true, LeaseDuration: 15 * time.Second, RenewDeadline: 10 * time.Second, RetryPeriod: 2 * time.Second, Callbacks: leaderelection.LeaderCallbacks{ OnStartedLeading: func(ctx context.Context) { klog.Info(\u0026#34;Started leading\u0026#34;) informerFactory.Start(ctx.Done()) // Start the controller logic }, OnStoppedLeading: func() { klog.Info(\u0026#34;Stopped leading\u0026#34;) le \u0026lt;- struct{}{} }, OnNewLeader: func(identity string) { if identity == os.Getenv(\u0026#34;POD_NAME\u0026#34;) { klog.Info(\u0026#34;I am the leader\u0026#34;) } else { klog.Infof(\u0026#34;New leader elected: %s\u0026#34;, identity) } }, }, }) 启动controller /cmd/my-controller.go\nmyController.Run(2, ctx.Done()) 业务逻辑写在 pkg/controller/contronller.go\nfunc (c *Controller) syncHandler(key string) error { namespace, name, err := cache.SplitMetaNamespaceKey(key) if err != nil { runtime.HandleError(fmt.Errorf(\u0026#34;invalid resource key: %s\u0026#34;, key)) return nil } myresource, err := c.myresourceLister.MyResources(namespace).Get(name) if err != nil { if errors.IsNotFound(err) { runtime.HandleError(fmt.Errorf(\u0026#34;myresource \u0026#39;%s\u0026#39; in work queue no longer exists\u0026#34;, key)) return nil } return err } fmt.Printf(\u0026#34;Sync/Add/Update for MyResource %s\\n\u0026#34;, myresource.GetName()) return nil } "},{"id":33,"href":"/docs/%E4%BA%91%E5%8E%9F%E7%94%9F/kubernetes/operate/","title":"operate","section":"Kubernetes","content":"欢迎使用kubernetes\n"},{"id":34,"href":"/docs/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","title":"动态规划","section":"算法","content":"本章节介绍贪心算法\n基本原理 # 最优子结构 一个问题的最优解包含其子问题的最优解，换句话说，问题的最优解可以通过子问题的最优解推到出来 重叠子问题 在求解过程中，子问题会被多次重复计算，动态规划通过存储子问题的解（通常使用表格或数组），避免重复计算 适用条件 # 最优化问题： 背包问题（0-1 背包、完全背包） 最短路径问题（Floyd-Warshall 算法） 最长公共子序列（LCS） 最大子数组和 计数问题： 组合数问题 路径计数问题 序列问题： 斐波那契数列 编辑距离（Levenshtein 距离） 步骤 # 定义状态 明确问题的状态表示，通常一个或多个变量描述问题的子问题 确定状态转移方程 找到状态之间的关系，即如何从子问题的解推导出当前问题的解 初始化 确定初始状态的值，通常问题的最小规模情况 计算顺序 按照一定的顺序计算状态，通常是自底向上（从最小子问题开始）或自顶向下（递归 + 记忆化） 返回结果 根据状态或数组返回最终问题的解 优化 # 空间优化： 如果状态转移方程只依赖于前一个状态，可以使用滚动数组或变量来减少空间复杂度。 例如：斐波那契数列问题可以优化为只使用两个变量。 记忆化搜索： 自顶向下的递归方法，通过缓存子问题的解来避免重复计算。 "},{"id":35,"href":"/docs/%E4%BA%91%E5%8E%9F%E7%94%9F/kubernetes/operate/%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BAkubeconfig/","title":"如何创建kubeConfig","section":"operate","content":" 如何创建kubeConfig # 创建clusterRole kubectl create clusterrole monitor --resource=prometheusrule --verb=\u0026#34;*\u0026#34; 创建clusterRoleBinding kubectl create clusterrolebinding monitor --clusterrole=rule --user monitor 生成普通用户令牌 cd /etc/kubernetes/pki #你的集群证书目录 user=monitor organization=monitoring clustername=cluster02 # 【集群地址，例如：https://172.21.114.169:6443】 api_addr=https://192.168.31.208:6443 time_days=365 #复制粘贴下面的代码即可 umask 077;openssl genrsa -out $user.key 2048 openssl req -new -key $user.key -out $user.csr -subj \u0026#34;/O=$organization/CN=$user\u0026#34; openssl x509 -req -in $user.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out $user.crt -days $time_days kubectl config set-cluster $clustername --server=$api_addr --certificate-authority=ca.crt --embed-certs=true --kubeconfig=/root/$user.config kubectl config set-credentials $user --client-certificate=$user.crt --client-key=$user.key --embed-certs=true --kubeconfig=/root/$user.config kubectl config set-context $user@$clustername --cluster=$clustername --user=$user --kubeconfig=/root/$user.config kubectl config use-context $user@$clustername --kubeconfig=/root/$user.config "},{"id":36,"href":"/docs/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/2.-%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/","title":"中序遍历","section":"二叉树","content":" 中序遍历 # 左子树 → 根 → 右子树\nfunc inorderTraversal(root *TreeNode) []int { if root == nil { return []int{} } stack, res := []*TreeNode{}, []int{} cur := root for cur != nil \u0026amp;\u0026amp; len(stack) \u0026gt; 0 { for cur != nil { stack = append(stack, cur) cur = cur.Left } cur = stack[len(stack)-1] stack = stack[:len(stack)-1] cur = root.Right } return res } "},{"id":37,"href":"/docs/%E4%BA%91%E5%8E%9F%E7%94%9F/kubernetes/operate/install/argo/","title":"argo","section":"install","content":"xxx\n"},{"id":38,"href":"/docs/%E4%BA%91%E5%8E%9F%E7%94%9F/cri/containerd/","title":"containerd","section":"CRI","content":"介绍使用containerd作为kubernetes CNI网络插件的使用\n"},{"id":39,"href":"/docs/%E4%BA%91%E5%8E%9F%E7%94%9F/cri/","title":"CRI","section":"云原生","content":"介绍使用containerd作为kubernetes CNI网络插件的使用\n"},{"id":40,"href":"/docs/%E4%BA%91%E5%8E%9F%E7%94%9F/kubernetes/questions/","title":"questions","section":"Kubernetes","content":"本文介绍kubernetes 常见的问题\n"},{"id":41,"href":"/docs/%E4%BA%91%E5%8E%9F%E7%94%9F/%E7%9B%91%E6%8E%A7/metrics/prometheus/questions/","title":"questions","section":"prometheus","content":"本人介绍prometheus 常见的问题\n"},{"id":42,"href":"/docs/%E4%BA%91%E5%8E%9F%E7%94%9F/%E7%9B%91%E6%8E%A7/metrics/thanos/","title":"thanos","section":"metrics","content":" "},{"id":43,"href":"/docs/%E4%BA%91%E5%8E%9F%E7%94%9F/%E7%9B%91%E6%8E%A7/trace/","title":"trace","section":"监控","content":"🔹 Trace 的工作原理\n1️⃣ 请求进入系统 •\t入口（如 API Gateway）生成一个 Trace ID •\t记录 起始时间\n2️⃣ 请求传播 •\t每个微服务 创建一个 Span •\t传递 Trace ID（上下文） •\t记录 时间、请求参数、响应时间\n3️⃣ 请求完成 •\t计算 每个服务的执行时间 •\t记录 错误信息 •\t上报 Trace 数据到 存储 \u0026amp; 可视化系统\n🔹 Trace 数据结构\n一个 Trace 由多个 Span 组成，每个 Span 记录：\n{ \u0026#34;trace_id\u0026#34;: \u0026#34;abcd-1234\u0026#34;, \u0026#34;span_id\u0026#34;: \u0026#34;efgh-5678\u0026#34;, \u0026#34;parent_id\u0026#34;: \u0026#34;ijkl-9101\u0026#34;, \u0026#34;service\u0026#34;: \u0026#34;user-service\u0026#34;, \u0026#34;operation\u0026#34;: \u0026#34;GET /user/info\u0026#34;, \u0026#34;start_time\u0026#34;: 1710000000000, \u0026#34;duration_ms\u0026#34;: 30, \u0026#34;tags\u0026#34;: { \u0026#34;http.status_code\u0026#34;: 200, \u0026#34;db.query\u0026#34;: \u0026#34;SELECT * FROM users\u0026#34; } } 🚀 总结\n✅ Trace 适用于分布式微服务，帮助分析慢请求、调用链\n✅ 核心概念：Trace、Span、上下文传播、存储 \u0026amp; 可视化\n✅ Jaeger、OpenTelemetry、Tempo 是常见的 Trace 方案\n✅ 相比传统日志，Trace 更适合故障排查 \u0026amp; 性能优化\n"},{"id":44,"href":"/docs/%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF/","title":"回溯","section":"算法","content":"本章节介绍回溯方法\n基本思想 # 尝试构建解（探索） 如果不满足条件，则回退（回溯） 如果满足条件，则记录解 步骤 # 选择（Choose）：尝试做出选择，向解空间深处探索。 约束（Constraint）：检查当前选择是否满足问题约束条件，若不满足则回退。 撤销（Unchoose）：如果该选择导致后续无解，则撤销选择，回到上一步。 优缺点 # 优点\n易于实现：代码结构清晰，递归思维自然适配回溯法。 能求所有解：适用于组合、排列、子集问题，能遍历所有可能方案。 适用于树形结构问题：如决策树、DFS 搜索路径。 可以结合剪枝优化：如 used[] 记录状态、提前终止无效搜索。 缺点 时间复杂度高： 组合：O(C(n, k)) ≈ 指数级 排列：O(n!)（非常高） 迷宫：最坏 O(4^n)（四个方向尝试） 重复计算： 例如编辑距离计算，回溯会重复计算子问题，导致超时。 优化：记忆化搜索 + 剪枝。 不适合大规模数据： 搜索空间太大时，直接超时！ 需要优化，如 剪枝、DP 代替回溯。 "},{"id":45,"href":"/docs/%E4%BA%91%E5%8E%9F%E7%94%9F/cni/cilium/","title":"cilium","section":"CNI","content":"介绍使用cilium作为kubernetes CNI网络插件的使用\n"},{"id":46,"href":"/docs/%E4%BA%91%E5%8E%9F%E7%94%9F/cni/","title":"CNI","section":"云原生","content":"介绍使用cilium作为kubernetes CNI网络插件的使用\n"},{"id":47,"href":"/docs/%E7%AE%97%E6%B3%95/%E5%8F%8C%E6%8C%87%E9%92%88/","title":"双指针","section":"算法","content":"本章节介绍双指针\n基本思想 # 双指针（Two Pointers） 是一种常用的算法优化技巧，通过两个指针（索引）在数组或链表上进行遍历，减少不必要的重复计算，提高效率。 适用于 数组、字符串、链表等线性结构，\n查找 比较 去重 排序等。 适用条件 # 有序数组/字符串/链表，方便利用 左右对撞 或 快慢遍历。 寻找特定组合（如和为 target），可以通过 对撞指针 避免暴力解法。 需要动态维护窗口（如最长无重复子串），滑动窗口可高效解决问题。 步骤 # 问题分解：将问题分为若干个子问题 局部最优选择：对每个子问题，选择一个局部最优解 合并解：将局部最优解合并为全局解 经典应用 # 活动选择问题：选择最多的互不重叠的活动。 霍夫曼编码：构造最优前缀编码。 最小生成树：如Prim算法和Kruskal算法。 最短路径问题：如Dijkstra算法。 背包问题的分数版本：选择单位价值最高的物品。 优缺点 # 优点\n降低时间复杂度 套循环，降低 O(n²) 为 O(n)，减少不必要的计算。 适用于有序结构 有序数组、单调递增序列 可用双指针 高效查找目标值。 空间复杂度低 一般只需 O(1) 额外空间，避免额外数组或哈希表。 缺点\n不适用于无序数组 例如 无序数组求和 不能直接用 对撞指针。 有些问题无法规避嵌套循环 例如 四数之和 仍然需要 O(n³)。 复杂情况需要额外逻辑 滑动窗口有时候需要 哈希表 记录状态。 "},{"id":48,"href":"/docs/linux/%E7%BD%91%E7%BB%9C/","title":"网络","section":"linux","content":" 欢迎使用 Hugo Book 主题！ # "},{"id":49,"href":"/docs/%E4%BA%91%E5%8E%9F%E7%94%9F/coredns/","title":"coreDNS","section":"云原生","content":"介绍使用Keycloak + OIDC\n"},{"id":50,"href":"/docs/%E7%AE%97%E6%B3%95/%E5%A0%86/","title":"堆","section":"算法","content":"本章节介绍堆\n基本思想 # 堆通常用完全二叉树实现，并存储在数组中，保证高效的插入和删除操作 最大堆：每个节点的值都大于等于其子节点的值，根节点是最大值 最小堆：每个节点的值都小于其子节点的值，根节点是最小值 存储方式 # 使用数组表示完全二叉树 操作 # 插入操作\n把新元素插入到数组末尾 上浮 删除堆顶元素\n用最后一个元素替换堆顶 下沉 堆排序\n构建最大堆 交换根节点和最后一个元素 调整堆 重复上述步骤，直到排序完成 经典应用 # 优先队列（Priority Queue） 使用最小堆实现任务优先级调度 使用最大堆实现Top K 问题 求TOP K 大/小元素 最小堆求TOP K 大元素 最大堆求TOP K 小元素 中位数维护 左边最大堆（维护较小的一半数） 右边最小堆（维护较大的一半数） 中位数为两堆的顶元素 优缺点 # 优点\n插入、删除 操作时间复杂度 O(log n) 动态维护 Top K 问题，适用于大数据场景 优先队列实现简单高效 缺点\n不支持快速查找（不像哈希表 O(1)） 堆排序不是稳定排序（相同元素相对顺序可能改变） 数组实现堆可能需要额外的空间移动 示例 # 最小堆\nimport \u0026#34;container/heap\u0026#34; type MinHeap []int func (h MinHeap) Len() int { return len(h) } func (h MinHeap) Less(i, j int) bool { return h[i] \u0026lt; h[j] } // 最小堆 func (h MinHeap) Swap(i, j int) { h[i], h[j] = h[j], h[i] } func (h *MinHeap) Push(x any) { *h = append(*h, x.(int)) } func (h *MinHeap) Pop() any { old := *h n := len(old) x := old[n-1] *h = old[:n-1] return x } func main() { h := \u0026amp;MinHeap{} heap.Init(h) heap.Push(h, 5) heap.Push(h, 2) heap.Push(h, 8) heap.Push(h, 1) fmt.Println(heap.Pop(h)) // 1 } "},{"id":51,"href":"/docs/%E4%BA%91%E5%8E%9F%E7%94%9F/ci/tekton/","title":"tekton","section":"CI","content":"介绍使用tekton\n"},{"id":52,"href":"/docs/%E7%AE%97%E6%B3%95/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/","title":"拓扑排序","section":"算法","content":"本章节介绍堆\n基本思想 # 拓扑排序（Topological Sorting）是 针对有向无环图（DAG, Directed Acyclic Graph）的一种排序方法，它的目标是将图中的所有顶点排序，使得对于每一条有向边 (u → v)，顶点 u 先出现在 v 之前。\nkahn算法（入度法） 维护所有入度0的节点（可以入队） 每次从队列中取出一个节点，并删除它指向的边，更新相邻节点的入度 若某个相邻节点入度变成0，则加入队列 知道所有节点都被访问完 DFS 逆序法 采用DFS遍历每个点，递归访问所有子节点 访问完所有后续节点后，将当前的节点压入栈 最终栈中的元素顺序即为拓扑排序的结果 经典应用 # 任务调度 场景：多个任务有前后依赖关系，必须按顺序执行。 示例：编译多个源代码文件时，需要先编译依赖文件。 课程安排（先修课程） 场景：某些课程需要先完成前置课程，才能学习后续课程。 示例：LeetCode 207 课程表（Course Schedule）问题。 电路时序分析 场景：计算电路中信号的传播顺序，确保数据按逻辑流动。 软件包依赖管理 场景：如 npm、pip 等包管理器，安装包时需要先安装其依赖项。 编译器优化 场景：代码中的函数调用优化，确定依赖关系，减少重复计算。 优缺点 # 优点\n高效性： Kahn 算法 时间复杂度 O(V + E)（遍历所有节点和边）。 DFS 逆序法 时间复杂度也是 O(V + E)。 易于实现： 代码简单，适用于有向无环图（DAG）。 解决依赖关系问题： 能很好地解决 任务调度、先修课程、软件包管理 等依赖问题。 缺点\n仅适用于 DAG： 不能处理有环图，如果图中有环，无法进行拓扑排序。 可能有多种拓扑排序结果： 拓扑排序的结果可能不是唯一的，不同的算法可能得出不同的合法顺序。 不能检测所有依赖冲突： 仅能发现 循环依赖（环），但无法处理复杂的冲突（如并发依赖）。 "},{"id":53,"href":"/docs/%E4%BA%91%E5%8E%9F%E7%94%9F/cd/argo/","title":"argo","section":"CD","content":"介绍使用argo\n"},{"id":54,"href":"/docs/%E4%BA%91%E5%8E%9F%E7%94%9F/ci/","title":"CI","section":"云原生","content":"介绍使用argo\n"},{"id":55,"href":"/docs/%E4%BA%91%E5%8E%9F%E7%94%9F/cd/","title":"CD","section":"云原生","content":"介绍使用argo\n"},{"id":56,"href":"/docs/%E7%AE%97%E6%B3%95/%E5%88%86%E6%B2%BB%E6%B3%95/","title":"分治法","section":"算法","content":"本章节介绍贪心算法\n基本思想 # 分解 将多个问题分成多个规模较小、相互独立的子问题 这些子问题的形式与原问题相似，但规模较小 解决 递归地求解这些子问题，直到问题的规模足够小，可以直接求解（通常较小规模的基本情况，如数组只有一个元素） 合并 将所有的子问题的解合并成原问题的解 经典应用 # 排序算法 归并排序（Merge Sort）：将数组拆分成两半，分别排序后合并。 快速排序（Quick Sort）：选择一个基准值（pivot），将数组划分为 小于基准值 和 大于基准值 的部分，然后递归排序。 计算数学 大整数乘法（Karatsuba算法）：将大整数拆分为较小的部分递归计算，提高乘法速度。 矩阵乘法（Strassen算法）：将矩阵拆分成更小的子矩阵，提高计算效率。 递归问题 汉诺塔问题：将问题分解为“移动 n-1 层盘子”的问题递归求解。 最大子数组和（分治法解法）：将数组拆分为左右两部分，求解最大子数组和。 计算几何 最近点对问题：将点集按 x 轴拆分，分别计算最近点对，然后合并结果。 凸包问题：使用分治法求解点集中凸包。 优缺点 # 优点\n易于理解和实现：递归思想清晰，代码结构往往简单直观。 高效：通常可以将问题的时间复杂度降至 O(n \\log n) 或更优，如 归并排序、快速排序。 适用于大规模问题：能够将复杂问题拆解成小问题，适用于 大数据处理。 并行计算：许多分治法算法可以 并行化（如 并行归并排序），提升执行效率。 缺点\n递归调用可能造成额外开销：如果递归深度过大，可能导致 栈溢出（Stack Overflow）。 额外的空间开销： 归并排序需要 额外的存储空间（O(n)）来存储合并后的结果。 快速排序（在原数组上进行，不需要额外空间）。 子问题可能不是完全独立的： 例如，动态规划 也使用递归，但存在 重叠子问题，需要通过 记忆化搜索（Memoization） 或 递推 进行优化。 "},{"id":57,"href":"/docs/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/","title":"二叉树","section":"算法","content":" 本章节介绍二叉树 # 二叉树的性质 # 节点总数： 深度为 h 的满二叉树最多有 2^{h} - 1 个节点。 高度（height） 从当前节点到叶子节点的最长路径上的边数 根节点的高度=整棵树的高度 深度（depth） 根节点的深度为0，某个节点的深度是从根节点到该节点的路径长度（边的数量） 层（level） 根节点为第1层，其子节点为第2层，以此类推 特殊类型的二叉树 # 满二叉树 # 每个节点要么有0个节点，要么有2个子节点（不存在只有一个节点的情况） 叶子节点都在同一层或者仅比最底层少一层 完全二叉树 # 除了最后一层，其他层的节点必须是满的 最后一层的叶子节点必须靠左排列 完美二叉树 # 所有的叶子节点必须处于同一层 节点数满足公式 2^h - 1（h 为高度） 平衡二叉树 # 任意节点的左右子树高度差不超过 1 典型代表：AVL 树，红黑树 二叉搜索树 # 左子树的所有节点值 \u0026lt; 根节点 \u0026lt; 右子树的所有节点值 中序遍历的结果是一个递增序列 二叉堆 # 最小堆：父节点 \u0026lt;= 子节点 最大堆: 父节点 \u0026gt;= 子节点 二叉树的遍历方式 # 1 / \\ 2 3 / \\ / \\ 4 5 6 7 / \\ / \\ / \\ / \\ 8 9 10 11 12 13 14 15 前序遍历 # 根 → 左子树 → 右子树\n访问当前节点 递归遍历左子树 递归遍历右子树 [1, 2, 4, 8, 9, 5, 10, 11, 3, 6, 12, 13, 7, 14, 15] 实现方式：递归/栈\n适用于：拷贝二叉树、前缀表达式计算。\n中序遍历 # 左子树 → 根 → 右子树\n递归遍历左子树 访问当前节点 递归遍历右子树 [8, 4, 9, 2, 10, 5, 11, 1, 12, 6, 13, 3, 14, 7, 15] 实现方式：递归/栈\n适用于：二叉搜索树（BST） 的升序遍历\n后续遍历 # 左子树 → 右子树 → 根\n递归遍历左子树 递归遍历右子树 访问根节点 [8, 9, 4, 10, 11, 5, 2, 12, 13, 6, 14, 15, 7, 3, 1] 实现方式：递归/两个栈\n适用于：删除节点、计算树的高度。\n层序遍历 # 依次访问每一层的节点，从上到下，从左到右 适用于：最短路径搜索（如 BFS 算法）\n"},{"id":58,"href":"/docs/%E4%BA%91%E5%8E%9F%E7%94%9F/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/","title":"权限管理","section":"云原生","content":"介绍使用Keycloak + OIDC\n"}]