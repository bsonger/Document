<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>questions on bei的个人博客</title>
    <link>http://localhost:1313/docs/%E4%BA%91%E5%8E%9F%E7%94%9F/kubernetes/questions/</link>
    <description>Recent content in questions on bei的个人博客</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <atom:link href="http://localhost:1313/docs/%E4%BA%91%E5%8E%9F%E7%94%9F/kubernetes/questions/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>创建一个无状态服务</title>
      <link>http://localhost:1313/docs/%E4%BA%91%E5%8E%9F%E7%94%9F/kubernetes/questions/%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%97%A0%E7%8A%B6%E6%80%81%E6%9C%8D%E5%8A%A1kubernetes%E7%9A%84%E5%86%85%E9%83%A8%E6%B5%81%E7%A8%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/%E4%BA%91%E5%8E%9F%E7%94%9F/kubernetes/questions/%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%97%A0%E7%8A%B6%E6%80%81%E6%9C%8D%E5%8A%A1kubernetes%E7%9A%84%E5%86%85%E9%83%A8%E6%B5%81%E7%A8%8B/</guid>
      <description>&lt;h2 id=&#34;创建一个deployment资源&#34;&gt;&#xA;  创建一个deployment资源&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%88%9b%e5%bb%ba%e4%b8%80%e4%b8%aadeployment%e8%b5%84%e6%ba%90&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;&lt;strong&gt;当创建一个deployment时，kubernetes 内部是如何处理的？&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;创建 Deployment 资源&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;用户通过 kubectl apply 或 API 直接创建一个 Deployment 资源。&lt;/li&gt;&#xA;&lt;li&gt;kube-apiserver 接收到请求后，将 Deployment 对象写入 etcd 数据库。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;ol start=&#34;2&#34;&gt;&#xA;&lt;li&gt;controller-manager 处理 Deployment&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;kube-controller-manager 监听 Deployment 资源（通过 watch 机制）。&lt;/li&gt;&#xA;&lt;li&gt;发现新建的 Deployment，DeploymentController 计算出需要创建的 ReplicaSet（如果是更新，还会进行滚动升级）。&lt;/li&gt;&#xA;&lt;li&gt;controller-manager 通过 kube-apiserver 创建 ReplicaSet 资源。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;ol start=&#34;3&#34;&gt;&#xA;&lt;li&gt;controller-manager 处理 ReplicaSet&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;kube-controller-manager 监听 ReplicaSet 资源（通过 watch 机制）。&lt;/li&gt;&#xA;&lt;li&gt;发现新建的 ReplicaSet，ReplicaSetController 计算出需要创建的 Pod。&lt;/li&gt;&#xA;&lt;li&gt;controller-manager 通过 kube-apiserver 创建 Pod 资源。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;ol start=&#34;4&#34;&gt;&#xA;&lt;li&gt;kube-scheduler 进行调度&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;kube-scheduler 监听 Pod 资源的变更（通过 watch 机制）。&lt;/li&gt;&#xA;&lt;li&gt;发现 Pod 处于 Pending 状态，调度器计算出合适的 Node（根据 CPU、内存、调度策略等）。&lt;/li&gt;&#xA;&lt;li&gt;kube-scheduler 通过 kube-apiserver 更新 Pod 的 spec.nodeName，分配到合适的节点。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;ol start=&#34;5&#34;&gt;&#xA;&lt;li&gt;kubelet 负责拉起容器&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;kubelet 监听 kube-apiserver，发现被分配到自己节点的 Pod。&lt;/li&gt;&#xA;&lt;li&gt;kubelet 通过 Container Runtime Interface (CRI) 执行：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;创建网络（调用 CNI 插件，分配 IP）。&lt;/li&gt;&#xA;&lt;li&gt;挂载存储（调用 CSI 插件，挂载 Volume）。&lt;/li&gt;&#xA;&lt;li&gt;启动容器（调用 CRI，使用 containerd 或 Docker 等创建容器）。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;kubelet 通过 kube-apiserver 更新 Pod 状态（Running）。&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/blockquote&gt;&#xA;&lt;h2 id=&#34;创建一个service资源&#34;&gt;&#xA;  创建一个service资源&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%88%9b%e5%bb%ba%e4%b8%80%e4%b8%aaservice%e8%b5%84%e6%ba%90&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;kube-proxy 监听 kube-apiserver 上的 service 资源的创建：&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;当 kube-proxy 监视到新的服务资源（Service）时，它会根据 Service 中的标签（labels）来筛选出符合条件的 Pod。这些 Pod 是与该 Service 相关联的目标（后端）。通过这些信息，kube-proxy 创建一个 Endpoints 资源对象，指向这些 Pod。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;ol start=&#34;2&#34;&gt;&#xA;&lt;li&gt;kube-proxy 监听 endpoint 资源的变化：&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Endpoints 资源对象被创建或更新，kube-proxy 就会动态地根据新的 Endpoint 信息来修改其网络规则（如 iptables 或 ipvs）。&lt;/li&gt;&#xA;&lt;li&gt;kube-proxy 根据 Endpoint 中的 Pod 地址创建或更新相应的 iptables 或 ipvs 规则，这样流量就可以通过正确的后端 Pod 进行路由。&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/blockquote&gt;</description>
    </item>
    <item>
      <title>网络</title>
      <link>http://localhost:1313/docs/%E4%BA%91%E5%8E%9F%E7%94%9F/kubernetes/questions/%E7%BD%91%E7%BB%9C/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/%E4%BA%91%E5%8E%9F%E7%94%9F/kubernetes/questions/%E7%BD%91%E7%BB%9C/</guid>
      <description>&lt;h2 id=&#34;kubernetes-容器提供一个服务外部访问慢如何排查是容器网络原因还是服务本身的问题&#34;&gt;&#xA;  kubernetes 容器提供一个服务，外部访问慢，如何排查是容器网络原因还是服务本身的问题&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#kubernetes-%e5%ae%b9%e5%99%a8%e6%8f%90%e4%be%9b%e4%b8%80%e4%b8%aa%e6%9c%8d%e5%8a%a1%e5%a4%96%e9%83%a8%e8%ae%bf%e9%97%ae%e6%85%a2%e5%a6%82%e4%bd%95%e6%8e%92%e6%9f%a5%e6%98%af%e5%ae%b9%e5%99%a8%e7%bd%91%e7%bb%9c%e5%8e%9f%e5%9b%a0%e8%bf%98%e6%98%af%e6%9c%8d%e5%8a%a1%e6%9c%ac%e8%ba%ab%e7%9a%84%e9%97%ae%e9%a2%98&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h2 id=&#34;如果容器内部没有sh-和网络工具如何查看pod-内部的网络连接&#34;&gt;&#xA;  如果容器内部没有sh 和网络工具，如何查看pod 内部的网络连接&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%a6%82%e6%9e%9c%e5%ae%b9%e5%99%a8%e5%86%85%e9%83%a8%e6%b2%a1%e6%9c%89sh-%e5%92%8c%e7%bd%91%e7%bb%9c%e5%b7%a5%e5%85%b7%e5%a6%82%e4%bd%95%e6%9f%a5%e7%9c%8bpod-%e5%86%85%e9%83%a8%e7%9a%84%e7%bd%91%e7%bb%9c%e8%bf%9e%e6%8e%a5&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;使用 kubectl debug&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;kubernetes 提供了kubectl debug让你可以在pod的网络namespace 内运行一个临时容器，该容器可以包含网络工具，如netstat、ss、curl、tcpdump等&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
